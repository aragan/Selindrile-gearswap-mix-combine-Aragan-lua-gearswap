--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
-- __________.__                                ________                          __               .__.__  __      __  .__    .__           _____.__.__              
-- \______   |  |   ____ _____    ______ ____   \______ \   ____     ____   _____/  |_    ____   __| _|___/  |_  _/  |_|  |__ |__| ______ _/ ____|__|  |   ____      
--  |     ___|  | _/ __ \\__  \  /  ____/ __ \   |    |  \ /  _ \   /    \ /  _ \   __\ _/ __ \ / __ ||  \   __\ \   __|  |  \|  |/  ___/ \   __\|  |  | _/ __ \     
--  |    |   |  |_\  ___/ / __ \_\___ \\  ___/   |    `   (  <_> ) |   |  (  <_> |  |   \  ___// /_/ ||  ||  |    |  | |   Y  |  |\___ \   |  |  |  |  |_\  ___/     
--  |____|   |____/\___  (____  /____  >\___  > /_______  /\____/  |___|  /\____/|__|    \___  \____ ||__||__|    |__| |___|  |__/____  >  |__|  |__|____/\___  > /\ 
--                     \/     \/     \/     \/          \/              \/                   \/     \/                      \/        \/                      \/  \/ 
--
--	Please do not edit this file!							Please do not edit this file!							Please do not edit this file!
--
--	Editing this file will cause you to be unable to use Github Desktop to update!
--
--	Any changes you wish to make in this file you should be able to make by overloading. That is Re-Defining the same variables or functions in another file, by copying and
--	pasting them to a file that is loaded after the original file, all of my library files, and then job files are loaded first.
--	The last files to load are the ones unique to you. User-Globals, Charactername-Globals, Charactername_Job_Gear, in that order, so these changes will take precedence.
--
--	You may wish to "hook" into existing functions, to add functionality without losing access to updates or fixes I make, for example, instead of copying and editing
--	status_change(), you can instead use the function user_status_change() in the same manner, which is called by status_change() if it exists, most of the important 
--  gearswap functions work like this in my files, and if it's unique to a specific job, user_job_status_change() would be appropriate instead.
--
--  Variables and tables can be easily redefined just by defining them in one of the later loaded files: autofood = 'Miso Ramen' for example.
--  States can be redefined as well: state.HybridMode:options('Normal','PDT') though most of these are already redefined in the gear files for editing there.
--	Commands can be added easily with: user_self_command(commandArgs, eventArgs) or user_job_self_command(commandArgs, eventArgs)
--
--	If you're not sure where is appropriate to copy and paste variables, tables and functions to make changes or add them:
--		User-Globals.lua - 			This file loads with all characters, all jobs, so it's ideal for settings and rules you want to be the same no matter what.
--		Charactername-Globals.lua -	This file loads with one character, all jobs, so it's ideal for gear settings that are usable on all jobs, but unique to this character.
--		Charactername_Job_Gear.lua-	This file loads only on one character, one job, so it's ideal for things that are specific only to that job and character.
--
--
--	If you still need help, feel free to contact me on discord or ask in my chat for help: https://discord.gg/ug6xtvQ
--  !Please do NOT message me in game about anything third party related, though you're welcome to message me there and ask me to talk on another medium.
--
--  Please do not edit this file!							Please do not edit this file!							Please do not edit this file!
-- __________.__                                ________                          __               .__.__  __      __  .__    .__           _____.__.__              
-- \______   |  |   ____ _____    ______ ____   \______ \   ____     ____   _____/  |_    ____   __| _|___/  |_  _/  |_|  |__ |__| ______ _/ ____|__|  |   ____      
--  |     ___|  | _/ __ \\__  \  /  ____/ __ \   |    |  \ /  _ \   /    \ /  _ \   __\ _/ __ \ / __ ||  \   __\ \   __|  |  \|  |/  ___/ \   __\|  |  | _/ __ \     
--  |    |   |  |_\  ___/ / __ \_\___ \\  ___/   |    `   (  <_> ) |   |  (  <_> |  |   \  ___// /_/ ||  ||  |    |  | |   Y  |  |\___ \   |  |  |  |  |_\  ___/     
--  |____|   |____/\___  (____  /____  >\___  > /_______  /\____/  |___|  /\____/|__|    \___  \____ ||__||__|    |__| |___|  |__/____  >  |__|  |__|____/\___  > /\ 
--                     \/     \/     \/     \/          \/              \/                   \/     \/                      \/        \/                      \/  \/ 
--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
-------------------------------------------------------------------------------------------------------------------
-- Setup functions for this job.  Generally should not be modified.
-------------------------------------------------------------------------------------------------------------------

--[[
    Custom commands:

    ExtraSongsMode may take one of three values: None, Dummy, FullLength

    You can set these via the standard 'set' and 'cycle' self-commands.  EG:
    gs c cycle ExtraSongsMode
    gs c set ExtraSongsMode Dummy

    The Dummy state will equip the bonus song instrument and ensure non-duration gear is equipped.
    The FullLength state will simply equip the bonus song instrument on top of standard gear.


    Simple macro to cast a dummy Daurdabla song:
    /console gs c set ExtraSongsMode Dummy
    /ma "Mage's Ballad" <me>

    To use a Terpander rather than Daurdabla, set the info.ExtraSongInstrument variable to
    'Terpander', and info.ExtraSongs to 1.
--]]

-- Initialization function for this job file.
function get_sets()
    -- Load and initialize the include file.
    include('Sel-Include.lua')
	organizer_items = {		
		"Airmid's Gorget",
		"Tumult's Blood",
		"Sarama's Hide",
		"Hidhaegg's Scale",
		"Sovereign's Hide",
		"Grape Daifuku",
		"Soy Ramen",
		"G. Curry Bun +1",
		"Pukatrice Egg",
		"Moogle Amp.",
		"Om. Sandwich",
		"Red Curry Bun",
		"Gyudon",
		"Reraiser",
		"Hi-Reraiser",
		"Vile Elixir",
		"Vile Elixir +1",
		"Miso Ramen",
		"Carbonara",
		"Silent Oil",
		"Salt Ramen",
		"Panacea",
		"Sublime Sushi",
		"Sublime Sushi 1+",
		"Prism Powder",
		"Antacid",
		"Icarus Wing",
		"Warp Cudgel",
		"Holy Water",
		"Sanjaku-Tenugui",
		"Shinobi-Tabi",
		"Shihei",
		"Remedy",
		"Emporox's Ring",
		"Red Curry Bun",
		"Instant Reraise",
		"Black Curry Bun",
		"Rolan. Daifuku",
		"Reraise Earring",
	}

end

-- Setup vars that are user-independent.  state.Buff vars initialized here will automatically be tracked.
function job_setup()
	send_command('lua l Singer')

    state.ExtraSongsMode = M{['description']='Extra Songs','FullLength','None','Dummy','FullLength','Marsyas'}
	-- Whether to use Carn (or song daggers in general) under a certain threshhold even when weapons are locked.
	state.CarnMode = M{'Always','300','1000','Never'}

	state.Buff['Aftermath: Lv.3'] = buffactive['Aftermath: Lv.3'] or false
    state.Buff['Pianissimo'] = buffactive['Pianissimo'] or false
	state.Buff['Nightingale'] = buffactive['Nightingale'] or false
	state.RecoverMode = M('35%', '60%', 'Always', 'Never')
    state.HippoMode = M(false, "Hippo")

	autows = "Rudra's Storm"
	autofood = 'Pear Crepe'
	autonuke = 'Absorb-TP'

	state.AutoSongMode = M(false, 'Auto Song Mode')

    state.Carol = M{['description']='Carol',
        'Fire Carol', 'Fire Carol II', 'Ice Carol', 'Ice Carol II', 'Wind Carol', 'Wind Carol II',
        'Earth Carol', 'Earth Carol II', 'Lightning Carol', 'Lightning Carol II', 'Water Carol', 'Water Carol II',
        'Light Carol', 'Light Carol II', 'Dark Carol', 'Dark Carol II',
        }

    state.Threnody1 = M{['description']='Threnody',
        'Fire Threnody II', 'Ice Threnody II', 'Wind Threnody II', 'Earth Threnody II',
        'Ltng. Threnody II', 'Water Threnody II', 'Light Threnody II', 'Dark Threnody II',
        }

    state.Etude = M{['description']='Etude',  'Herculean Etude', 'Sage Etude', 'Sinewy Etude', 'Learned Etude',
        'Quick Etude', 'Swift Etude', 'Vivacious Etude', 'Vital Etude', 'Dextrous Etude', 'Uncanny Etude',
        'Spirited Etude', 'Logical Etude', 'Enchanting Etude', 'Bewitching Etude'}

	state.Etude1 = M{['description']='Etude',  'Herculean Etude', 'Sage Etude', 'Sinewy Etude', 'Learned Etude',
        'Quick Etude', 'Swift Etude', 'Vivacious Etude', 'Vital Etude', 'Dextrous Etude', 'Uncanny Etude',
        'Spirited Etude', 'Logical Etude', 'Enchanting Etude', 'Bewitching Etude'}

	state.Songset = M{['description']='Songset','mboze', 'xevioso', 'kalunga', 'ngai','arebati', 'ongo', 'bumba',
		'haste','haste4', 'magic', 'aria', 'ph','sortie4', 'ody4', 'ody','sortie',}


	update_melee_groups()
	init_job_states({"Capacity","AutoRuneMode","AutoTrustMode","AutoNukeMode","AutoWSMode","AutoShadowMode","AutoFoodMode","AutoStunMode","AutoDefenseMode","AutoSongMode","HippoMode","AutoMedicineMode"},{"AutoBuffMode","AutoSambaMode","Weapons","OffenseMode","WeaponskillMode","IdleMode","Songset","Passive","RuneElement","ExtraSongsMode","ElementalMode","CastingMode","CarnMode","Etude","TreasureMode",})
end

-------------------------------------------------------------------------------------------------------------------
-- Job-specific hooks for standard casting events.
-------------------------------------------------------------------------------------------------------------------
-- Set eventArgs.handled to true if we don't want any automatic gear equipping to be done.
-- Set eventArgs.useMidcastGear to true if we want midcast gear equipped on precast.

-- Set eventArgs.handled to true if we don't want any automatic target handling to be done.

function job_filtered_action(spell, eventArgs)
	if spell.type == 'WeaponSkill' then
		local available_ws = S(windower.ffxi.get_abilities().weapon_skills)
		-- WS 112 is Double Thrust, meaning a Spear is equipped.
		if available_ws:contains(32) then
            if spell.english == "Rudra's Storm" then
				windower.chat.input('/ws "Savage Blade" '..spell.target.raw)
                cancel_spell()
				eventArgs.cancel = true
            end
        end
	end
end

function job_pretarget(spell, spellMap, eventArgs)
    if spell.type == 'BardSong' and not spell.targets.Enemy then
		if state.Buff['Pianissimo'] and spell.target.raw == '<t>' and (player.target.type == 'NONE' or spell.target.type == 'MONSTER') then
			eventArgs.cancel = true
			windower.chat.input('/ma "'..spell.name..'" <stpt>')
		elseif spell.target.raw == '<t>' and (player.target.type == 'NONE' or player.target.type == "MONSTER") and not state.Buff['Pianissimo'] then
			change_target('<me>')
			return
		end
    end
end

function job_precast(spell, spellMap, eventArgs)
	if spell.action_type == 'Magic' then
		if spell.english:contains('Honor March') then
			equip({range="Marsyas"})
		end
		if spell.english:contains('Aria of Passion') then
			equip({range="Loughnashade"})
		end
		if not sets.precast.FC[spell.english] and (spell.type == 'BardSong' and spell.targets.Enemy) then
			classes.CustomClass = 'SongDebuff'
		end
	end
end

function job_filter_precast(spell, spellMap, eventArgs)
    if spell.type == 'BardSong' and not spell.targets.Enemy then
		local spell_recasts = windower.ffxi.get_spell_recasts()
		
        -- Auto-Pianissimo
        if ((spell.target.type == 'PLAYER' and not spell.target.charmed) or (spell.target.type == 'NPC')) and spell.target.in_party and not state.Buff['Pianissimo'] then
            if spell_recasts[spell.recast_id] < 1.5 then
                send_command('@input /ja "Pianissimo" <me>; wait 1.1; input /ma "'..spell.name..'" '..spell.target.name)
                eventArgs.cancel = true
            end
        end
    end
end

-- Set eventArgs.handled to true if we don't want any automatic gear equipping to be done.
function job_midcast(spell, spellMap, eventArgs)
    if spell.action_type == 'Magic' then
        if spell.type == 'BardSong' then
            -- layer general gear on first, then let default handler add song-specific gear.
            local generalClass = get_song_class(spell)
			if generalClass and sets.midcast[generalClass] then
				if sets.midcast[generalClass][state.CastingMode.value] then
					equip(sets.midcast[generalClass][state.CastingMode.value])
				else
					equip(sets.midcast[generalClass])
				end
            end
			if state.CarnMode.value ~= 'Never' and (state.CarnMode.value == 'Always' or tonumber(state.CarnMode.value) > player.tp) then
				if sets.midcast[generalClass].main and sets.midcast[generalClass].main ~= player.equipment.main then
					enable('main')
					equip({main=sets.midcast[generalClass].main})
				end
				if sets.midcast[generalClass].sub and sets.midcast[generalClass].sub ~= player.equipment.sub then
					enable('sub')
					equip({sub=sets.midcast[generalClass].sub})
				end
			end
        end
    end
end

function job_post_precast(spell, spellMap, eventArgs)
	if spell.type == 'BardSong' then

		local generalClass = get_song_class(spell)
	
		if state.Buff['Nightingale'] then
		
			-- Replicate midcast in precast for nightingale including layering.
			if generalClass and sets.midcast[generalClass] then
				if sets.midcast[generalClass][state.CastingMode.value] then
					equip(sets.midcast[generalClass][state.CastingMode.value])
				else 
					equip(sets.midcast[generalClass])
				end
            end

			if sets.midcast[spell.english] then
				if sets.midcast[spell.english][state.CastingMode.value] then
					equip(sets.midcast[spell.english][state.CastingMode.value])
				else
					equip(sets.midcast[spell.english])
				end
			elseif sets.midcast[get_spell_map(spell, default_spell_map)] then
				if sets.midcast[get_spell_map(spell, default_spell_map)][state.CastingMode.Value]
					then equip(sets.midcast[get_spell_map(spell, default_spell_map)][state.CastingMode.Value])
				else
					equip(sets.midcast[get_spell_map(spell, default_spell_map)])
				end
			end
			

		
		end

		if state.CarnMode.value ~= 'Never' and (state.CarnMode.value == 'Always' or tonumber(state.CarnMode.value) > player.tp) then
			if sets.precast.FC.BardSong.main and sets.precast.FC.BardSong.main ~= player.equipment.main then
				enable('main')
				equip({main=sets.precast.FC.BardSong.main})
			end
			if sets.precast.FC.BardSong.sub and sets.precast.FC.BardSong.sub ~= player.equipment.sub then
				enable('sub')
				equip({sub=sets.precast.FC.BardSong.sub})
			end
		end

	elseif spell.type == 'WeaponSkill' then
		local WSset = standardize_set(get_precast_set(spell, spellMap))
		local wsacc = check_ws_acc()
		
		if (WSset.ear1 == "Moonshade Earring" or WSset.ear2 == "Moonshade Earring") then
			-- Replace Moonshade Earring if we're at cap TP
			if get_effective_player_tp(spell, WSset) > 3200 then
				if wsacc:contains('Acc') and not buffactive['Sneak Attack'] and sets.AccMaxTP then
					equip(sets.AccMaxTP[spell.english] or sets.AccMaxTP)
				elseif sets.MaxTP then
					equip(sets.MaxTP[spell.english] or sets.MaxTP)
				else
				end
			end
		end
	end
end

function job_post_midcast(spell, spellMap, eventArgs)
    if spell.type == 'BardSong' then
		if spell.targets.Enemy then
			if sets.midcast[spell.english] then
				if sets.midcast[spell.english][state.CastingMode.value] then
					equip(sets.midcast[spell.english][state.CastingMode.value])
				else
					equip(sets.midcast[spell.english])
				end
			elseif sets.midcast[spellMap] then
				if sets.midcast[spellMap][state.CastingMode.value] then
					equip(sets.midcast[spellMap][state.CastingMode.value])
				else
					equip(sets.midcast[spellMap])
				end
			end
			
			if can_dual_wield and sets.midcast.SongDebuff.DW then
				equip(sets.midcast.SongDebuff.DW)
			end
		else
			if can_dual_wield and sets.midcast.SongEffect.DW then
				equip(sets.midcast.SongEffect.DW)
			end
		end
		


        --[[if not state.ExtraSongsMode.value:contains('Lock') then
			state.ExtraSongsMode:reset()
		end]]

		if state.DisplayMode.value then update_job_states()	end

    elseif spell.skill == 'Elemental Magic' and default_spell_map ~= 'ElementalEnfeeble' then
        if state.MagicBurstMode.value ~= 'Off' then equip(sets.MagicBurst) end
		if spell.element == world.weather_element or spell.element == world.day_element then
			if state.CastingMode.value == 'Fodder' then
				if spell.element == world.day_element then
					if item_available('Zodiac Ring') then
						sets.ZodiacRing = {ring2="Zodiac Ring"}
						equip(sets.ZodiacRing)
					end
				end
			end
		end

		if spell.element == 'Wind' and sets.WindNuke then
			equip(sets.WindNuke)
		elseif spell.element == 'Ice' and sets.IceNuke then
			equip(sets.IceNuke)
		end

		if state.RecoverMode.value ~= 'Never' and (state.RecoverMode.value == 'Always' or tonumber(state.RecoverMode.value:sub(1, -2)) > player.mpp) then
			equip(sets.RecoverMP)
		end
    end
end

-- Set eventArgs.handled to true if we don't want automatic gear equipping to be done.
function job_aftercast(spell, spellMap, eventArgs)
	
	if spell.type == 'BardSong' and not spell.interrupted then
		if state.CarnMode.value ~= 'Never' then
			local generalClass = get_song_class(spell)
			if sets.midcast[generalClass].main and sets.weapons[state.Weapons.value] then
				if sets.weapons[state.Weapons.value].main then
					equip({main=sets.weapons[state.Weapons.value].main})
					disable('main')
				end
				if sets.weapons[state.Weapons.value].sub then
					equip({sub=sets.weapons[state.Weapons.value].sub})
					disable('sub')
				end
			end
		end

	elseif spell.skill == 'Elemental Magic' and state.MagicBurstMode.value == 'Single' then
		state.MagicBurstMode:reset()
		if state.DisplayMode.value then update_job_states()	end
    end

end

function job_buff_change(buff, gain)
	update_melee_groups()
    if buff == "Charm" then
        if gain then  			
           send_command('input /p Charmd, please Sleep me.')		
        else	
           send_command('input /p '..player.name..' is no longer Charmed, please wake me up!')
        end
    end
    if buff == "petrification" then
        if gain then    
            equip(sets.defense.PDT)
            send_command('input /p Petrification, please Stona.')		
        else
        send_command('input /p '..player.name..' is no longer Petrify!')
        handle_equipping_gear(player.status)
        end
    end
    if buff == "sleep" then
        if gain then    
            send_command('input /p ZZZzzz, please cure.')		
        else
            send_command('input /p '..player.name..' is no longer Sleep!')
        end
    end
end

function job_get_spell_map(spell, default_spell_map)

	if  default_spell_map == 'Cure' or default_spell_map == 'Curaga'  then
		if world.weather_element == 'Light' then
                return 'LightWeatherCure'
		elseif world.day_element == 'Light' then
                return 'LightDayCure'
        end

	elseif spell.skill == "Enfeebling Magic" then
		if spell.english:startswith('Dia') then
			return "Dia"
		elseif spell.type == "WhiteMagic" or spell.english:startswith('Frazzle') or spell.english:startswith('Distract') then
			return 'MndEnfeebles'
		else
			return 'IntEnfeebles'
		end
	end
end

-------------------------------------------------------------------------------------------------------------------
-- Job-specific hooks for non-casting events.
-------------------------------------------------------------------------------------------------------------------

-------------------------------------------------------------------------------------------------------------------
-- User code that supplements standard library decisions.
-------------------------------------------------------------------------------------------------------------------

function job_zone_change(new_id,old_id)
	state.AutoSongMode:reset()
end

-- Called by the 'update' self-command.
function job_update(cmdParams, eventArgs)
	update_melee_groups()
end


-- Modify the default idle set after it was constructed.
function job_customize_idle_set(idleSet)
    if buffactive['Sublimation: Activated'] then
        if (state.IdleMode.value == 'Normal' or state.IdleMode.value:contains('Sphere')) and sets.buff.Sublimation then
            idleSet = set_combine(idleSet, sets.buff.Sublimation)
        elseif state.IdleMode.value:contains('DT') and sets.buff.DTSublimation then
            idleSet = set_combine(idleSet, sets.buff.DTSublimation)
        end
    end

    if state.IdleMode.value == 'Normal' or state.IdleMode.value:contains('Sphere') then
		if player.mpp < 51 then
			if sets.latent_refresh then
				idleSet = set_combine(idleSet, sets.latent_refresh)
			end
			
			if (state.Weapons.value == 'None' or state.UnlockWeapons.value) and idleSet.main then
				local main_table = get_item_table(idleSet.main)

				if  main_table and main_table.skill == 12 and sets.latent_refresh_grip then
					idleSet = set_combine(idleSet, sets.latent_refresh_grip)
				end
				
				if player.tp > 10 and sets.TPEat then
					idleSet = set_combine(idleSet, sets.TPEat)
				end
			end
		end
    end
    if state.HippoMode.value == true then 
        idleSet = set_combine(idleSet, {feet="Hippo. Socks +1"})
    end
    return idleSet
end
function customize_melee_set(meleeSet)
    if state.TreasureMode.value == 'Fulltime' then
        meleeSet = set_combine(meleeSet, sets.TreasureHunter)
    end

    return meleeSet
end




-- Function to display the current relevant user state when doing an update.
function display_current_job_state(eventArgs)
    display_current_caster_state()
    eventArgs.handled = true
end

-------------------------------------------------------------------------------------------------------------------
-- Utility functions specific to this job.
-------------------------------------------------------------------------------------------------------------------

-- Determine the custom class to use for the given song.
function get_song_class(spell)
    -- Can't use spell.targets:contains() because this is being pulled from resources
    if spell.targets.Enemy then
		return 'SongDebuff'
    elseif state.ExtraSongsMode.value:contains('Dummy') then
        return 'DaurdablaDummy'
    elseif state.ExtraSongsMode.value == 'FullLength' then
        return 'Gjallarhorn'
    elseif state.ExtraSongsMode.value == 'Marsyas' then
        return 'Marsyas'
    else
        return 'SongEffect'
    end
end

-- Examine equipment to determine what our current TP weapon is.
function update_melee_groups()
	if player.equipment.main then
		classes.CustomMeleeGroups:clear()

		if player.equipment.main == "Carnwenhan" and state.Buff['Aftermath: Lv.3'] then
				classes.CustomMeleeGroups:append('AM')
		end
	end
end

    -- Allow jobs to override this code
function job_self_command(commandArgs, eventArgs)
	if commandArgs[1]:lower() == 'elemental' then
		handle_elemental(commandArgs)
		eventArgs.handled = true			
	end


    if commandArgs[1]:lower() == 'etude' then
        send_command('@input /ma "'..state.Etude.value..'" <stpc>')
    elseif commandArgs[1]:lower() == 'carol' then
        send_command('@input /ma "'..state.Carol.value..'" <stpc>')
    elseif commandArgs[1]:lower() == 'threnody1' then
        send_command('@input /ma "'..state.Threnody.value..'" <stnpc>')
    end
	if commandArgs[1]:lower() == 'songsetnoph' then
		send_command('@input //abb "'..state.Songset.value..'" noph')
	elseif commandArgs[1]:lower() == 'songsetph' then
		send_command('@input //abb "'..state.Songset.value..'" ph')
	elseif commandArgs[1]:lower() == 'songsetphccsv' then
		send_command('@input //abb "'..state.Songset.value..'" ph ccsv')
	elseif commandArgs[1]:lower() == 'songset' then
		send_command('@input //abb "'..state.Songset.value..'" ccsv') 
	end
end

-- Handling Elemental spells within Gearswap.
-- Format: gs c elemental <nuke, helix, skillchain1, skillchain2, weather>
function handle_elemental(cmdParams)
    -- cmdParams[1] == 'elemental'
    -- cmdParams[2] == ability to use

    if not cmdParams[2] then
        add_to_chat(123,'Error: No elemental command given.')
        return
    end
    local command = cmdParams[2]:lower()

	if command == 'spikes' then
		windower.chat.input('/ma "'..data.elements.spikes_of[state.ElementalMode.value]..' Spikes" <me>')
		return
	elseif command == 'enspell' then
		windower.chat.input('/ma "En'..data.elements.enspell_of[state.ElementalMode.value]..'" <me>')
		return

	elseif command == 'carol' then
		windower.chat.input('/ma "'..data.elements.carol_of[state.ElementalMode.value]..' carol II" <stpc>')
		return
	--Leave out target, let shortcuts auto-determine it.
	elseif command == 'weather' then
		if player.sub_job == 'RDM' then
			windower.chat.input('/ma "Phalanx" <me>')
		else
			local spell_recasts = windower.ffxi.get_spell_recasts()
			if (player.target.type == 'SELF' or not player.target.in_party) and buffactive[data.elements.storm_of[state.ElementalMode.value]] and not buffactive['Klimaform'] and spell_recasts[287] < spell_latency then
				windower.chat.input('/ma "Klimaform" <me>')
			else
				windower.chat.input('/ma "'..data.elements.storm_of[state.ElementalMode.value]..'"')
			end
		end
		return
	end

	local target = '<t>'
	if cmdParams[3] then
		if tonumber(cmdParams[3]) then
			target = tonumber(cmdParams[3])
		else
			target = table.concat(cmdParams, ' ', 3)
			target = get_closest_mob_id_by_name(target) or '<t>'
		end
	end

    if command == 'nuke' then
		local spell_recasts = windower.ffxi.get_spell_recasts()

		if state.ElementalMode.value == 'Light' then
			if spell_recasts[29] < spell_latency and actual_cost(get_spell_table_by_name('Banish II')) < player.mp then
				windower.chat.input('/ma "Banish II" '..target..'')
			elseif spell_recasts[28] < spell_latency and actual_cost(get_spell_table_by_name('Banish')) < player.mp then
				windower.chat.input('/ma "Banish" '..target..'')
			else
				add_to_chat(123,'Abort: Banishes on cooldown or not enough MP.')
			end
		else
			if player.job_points[(res.jobs[player.main_job_id].ens):lower()].jp_spent > 99 and spell_recasts[get_spell_table_by_name(data.elements.nuke_of[state.ElementalMode.value]..' V').id] < spell_latency and actual_cost(get_spell_table_by_name(data.elements.nuke_of[state.ElementalMode.value]..' V')) < player.mp then
				windower.chat.input('/ma "'..data.elements.nuke_of[state.ElementalMode.value]..' II" '..target..'')
			else
				local tiers = {' II',''}
				for k in ipairs(tiers) do
					if spell_recasts[get_spell_table_by_name(data.elements.nuke_of[state.ElementalMode.value]..''..tiers[k]..'').id] < spell_latency and actual_cost(get_spell_table_by_name(data.elements.nuke_of[state.ElementalMode.value]..''..tiers[k]..'')) < player.mp then
						windower.chat.input('/ma "'..data.elements.nuke_of[state.ElementalMode.value]..''..tiers[k]..'" '..target..'')
						return
					end
				end
				add_to_chat(123,'Abort: All '..data.elements.nuke_of[state.ElementalMode.value]..' nukes on cooldown or or not enough MP.')
			end
		end

	elseif command == 'ninjutsu' then
		windower.chat.input('/ma "'..data.elements.ninjutsu_nuke_of[state.ElementalMode.value]..': Ni" '..target..'')

	elseif command == 'smallnuke' then
		local spell_recasts = windower.ffxi.get_spell_recasts()

		local tiers = {' II',''}
		for k in ipairs(tiers) do
			if spell_recasts[get_spell_table_by_name(data.elements.nuke_of[state.ElementalMode.value]..''..tiers[k]..'').id] < spell_latency and actual_cost(get_spell_table_by_name(data.elements.nuke_of[state.ElementalMode.value]..''..tiers[k]..'')) < player.mp then
				windower.chat.input('/ma "'..data.elements.nuke_of[state.ElementalMode.value]..''..tiers[k]..'" '..target..'')
				return
			end
		end
		add_to_chat(123,'Abort: All '..data.elements.nuke_of[state.ElementalMode.value]..' nukes on cooldown or or not enough MP.')

	elseif command:startswith('tier') then
		local spell_recasts = windower.ffxi.get_spell_recasts()
		local tierlist = {['tier1']='',['tier2']=' II',['tier3']=' III',['tier4']=' IV',['tier5']=' V',['tier6']=' VI'}

		windower.chat.input('/ma "'..data.elements.nuke_of[state.ElementalMode.value]..tierlist[command]..'" '..target..'')

	elseif command:startswith('ara') then
		local spell_recasts = windower.ffxi.get_spell_recasts()
		local tierkey = {'ara3','ara2','ara1'}
		local tierlist = {['ara3']='ra III',['ara2']='ra II',['ara1']='ra'}
		
		
		if command == 'ara' then
			for i in ipairs(tierkey) do
				if spell_recasts[get_spell_table_by_name(data.elements.nukera_of[state.ElementalMode.value]..''..tierlist[tierkey[i]]..'').id] < spell_latency and actual_cost(get_spell_table_by_name(data.elements.nukera_of[state.ElementalMode.value]..''..tierlist[tierkey[i]]..'')) < player.mp then
					windower.chat.input('/ma "'..data.elements.nukera_of[state.ElementalMode.value]..''..tierlist[tierkey[i]]..'" '..target..'')
					return
				end
			end
		else
			windower.chat.input('/ma "'..data.elements.nukera_of[state.ElementalMode.value]..tierlist[command]..'" '..target..'')
		end

	elseif command == 'aga' then
		windower.chat.input('/ma "'..data.elements.nukega_of[state.ElementalMode.value]..'ga" '..target..'')

	elseif command == 'helix' then
		windower.chat.input('/ma "'..data.elements.helix_of[state.ElementalMode.value]..'helix" '..target..'')

	elseif command == 'enfeeble' then
		windower.chat.input('/ma "'..data.elements.elemental_enfeeble_of[state.ElementalMode.value]..'" '..target..'')

	elseif command == 'bardsong' then
		windower.chat.input('/ma "'..data.elements.threnody_of[state.ElementalMode.value]..' Threnody" '..target..'')
	elseif command == 'threnody' then
		windower.chat.input('/ma "'..data.elements.threnody_of[state.ElementalMode.value]..' threnody II" '..target..'')
		
    else
        add_to_chat(123,'Unrecognized elemental command.')
    end

end

function job_tick()
	if check_song() then return true end
	if check_buff() then return true end
	if check_buffup() then return true end
	return false
end

mov = {counter=0}
if player and player.index and windower.ffxi.get_mob_by_index(player.index) then
    mov.x = windower.ffxi.get_mob_by_index(player.index).x
    mov.y = windower.ffxi.get_mob_by_index(player.index).y
    mov.z = windower.ffxi.get_mob_by_index(player.index).z
end

moving = false
windower.raw_register_event('prerender',function()
    mov.counter = mov.counter + 1;
    if state.HippoMode.value == true then 
        moving = false
	end
end)

function check_song()
	if state.AutoSongMode.value then
		if not buffactive.march then
			windower.chat.input('/ma "Honor March" <me>;wait 5;input /ma "Victory March" <me>')
			tickdelay = os.clock() + 2
			return true
		elseif not buffactive.minuet then
			windower.chat.input('//gs c set ExtraSongsMode Dummy;/ma "Valor Minuet V" <me>;wait 5;input /ma "Valor Minuet IV" <me>')
			tickdelay = os.clock() + 2
			return true
		--[[elseif not buffactive.madrigal then
			windower.send_command('//gs c set ExtraSongsMode Dummy;input /ma "Blade Madrigal" <me>') --gs c set ExtraSongsMode FullLength;input 
			tickdelay = os.clock() + 2
			return true]]
		else
			return false
		end
	else
		return false
	end
end

function check_buff()
	if state.AutoBuffMode.value ~= 'Off' and not data.areas.cities:contains(world.area) then
		local spell_recasts = windower.ffxi.get_spell_recasts()
		for i in pairs(buff_spell_lists[state.AutoBuffMode.Value]) do
			if not buffactive[buff_spell_lists[state.AutoBuffMode.Value][i].Buff] and (buff_spell_lists[state.AutoBuffMode.Value][i].When == 'Always' or (buff_spell_lists[state.AutoBuffMode.Value][i].When == 'Combat' and (player.in_combat or being_attacked)) or (buff_spell_lists[state.AutoBuffMode.Value][i].When == 'Engaged' and player.status == 'Engaged') or (buff_spell_lists[state.AutoBuffMode.Value][i].When == 'Idle' and player.status == 'Idle') or (buff_spell_lists[state.AutoBuffMode.Value][i].When == 'OutOfCombat' and not (player.in_combat or being_attacked))) and spell_recasts[buff_spell_lists[state.AutoBuffMode.Value][i].SpellID] < spell_latency and silent_can_use(buff_spell_lists[state.AutoBuffMode.Value][i].SpellID) then

				windower.chat.input:schedule(3,'//input /ma "'..buff_spell_lists[state.AutoBuffMode.Value][i].Name..'" <me>')
				windower.chat.input('//gs c set ExtraSongsMode Dummy')

				tickdelay = os.clock() + 2
				return true
			end
		end
	else
		return false
	end
end

function check_buffup()
	if buffup ~= '' then
		local needsbuff = false
		for i in pairs(buff_spell_lists[buffup]) do
			if not buffactive[buff_spell_lists[buffup][i].Buff] and silent_can_use(buff_spell_lists[buffup][i].SpellID) then
				needsbuff = true
				break
			end
		end
	
		if not needsbuff then
			add_to_chat(217, 'All '..buffup..' buffs are up!')
			buffup = ''
			return false
		end
		
		local spell_recasts = windower.ffxi.get_spell_recasts()
		
		for i in pairs(buff_spell_lists[buffup]) do
			if not buffactive[buff_spell_lists[buffup][i].Buff] and silent_can_use(buff_spell_lists[buffup][i].SpellID) and spell_recasts[buff_spell_lists[buffup][i].SpellID] < spell_latency then
				windower.chat.input('/ma "'..buff_spell_lists[buffup][i].Name..'" <me>')
				windower.chat.input('//gs c set ExtraSongsMode Dummy')
				tickdelay = os.clock() + 2
				return true
			end
		end
		
		return false
	else
		return false
	end
end

buff_spell_lists = {
	Auto = {--Options for When are: Always, Engaged, Idle, OutOfCombat, Combat
     	{Name='Honor March',	Buff='March',			SpellID=417,	When='Idle'},
		{Name='Valor Minuet V',	Buff='Minuet',			SpellID=398,	When='Idle'},
		{Name='Valor Minuet IV',Buff='Minuet',			SpellID=397,	When='Idle'},
		{Name='Blade Madrigal',Buff='Madrigal',			SpellID=400,	When='Idle'},

		--{Name='Refresh',			Buff='Refresh',			SpellID=109,	When='Idle'},
		--{Name='Phalanx',			Buff='Phalanx',			SpellID=106,	When='Idle'},
		--{Name='Stoneskin',			Buff='Stoneskin',		SpellID=54,		When='Idle'},
		--{Name='Blink',				Buff='Blink',			SpellID=53,		When='Idle'},
	},
	Regen = {--Options for When are: Always, Engaged, Idle, OutOfCombat, Combat
		{Name='Army\'s Paeon VI',	Buff='Paeon',		SpellID=383,	When='Idle'},
    },
	Default = {
		--{Name='Army\'s Paeon VI',	Buff='Paeon',			SpellID=383,	Reapply=false},
		{Name='Honor March',	Buff='March',			SpellID=417,	Reapply=false},
		{Name='Valor Minuet V',	Buff='Minuet',			SpellID=398,	Reapply=false},
		{Name='Valor Minuet IV',Buff='Minuet',			SpellID=397,	Reapply=false},
		{Name='Blade Madrigal',Buff='Madrigal',			SpellID=400,	Reapply=false},
		--{Name='Refresh',			Buff='Refresh',			SpellID=109,	Reapply=false},
		--{Name='Phalanx',			Buff='Phalanx',			SpellID=106,	Reapply=false},
		--{Name='Stoneskin',			Buff='Stoneskin',		SpellID=54,		Reapply=false},
		--{Name='Blink',				Buff='Blink',			SpellID=53,		Reapply=false},
	},
	Regen = {--Options for When are: Always, Engaged, Idle, OutOfCombat, Combat
	{Name='Army\'s Paeon VI',	Buff='Paeon',			SpellID=383,	Reapply=false},
    },
}















--------





--[[  

archive for save info


    DaurdSongs = T{"Army's Paeon","Army's Paeon II","Army's Paeon III","Army's Paeon IV","Army's Paeon V",}
    Daurdabla_Index = 2


function equip_song_gear(spell)
    if DaurdSongs:contains(spell.english) then
        equip(sets.midcast.Base,sets.midcast.DBuff)
    else
    if spell.target.type == 'MONSTER' then
        equip(sets.midcast.Base,sets.midcast.Debuff,sets.midcast.GBuff)
    if buffactive.troubadour or buffactive['elemental seal'] then
        equip(sets.midcast.Duration,{range="Marsyas",ammo="empty"})
        end
    if string.find(spell.english,'Lullaby') then equip(sets.midcast.Duration,sets.midcast.Lullaby) end
        else
        equip(sets.midcast.Base,sets.midcast.Buff,sets.midcast.GBuff)
			
    if spell.english == 'Honor March' then equip(sets.midcast['Honor March'])
        elseif string.find(spell.english,'Ballad') then equip(sets.midcast.Ballad)
        elseif string.find(spell.english,'Scherzo') then equip(sets.midcast.Scherzo)
        elseif string.find(spell.english,'Paeon') then equip(sets.midcast.Paeon)
        elseif string.find(spell.english,'Prelude') then equip(sets.midcast.Prelude)
        elseif string.find(spell.english,'Madrigal') then equip(sets.midcast.Madrigal)
        elseif string.find(spell.english,'Lullaby') then equip(sets.midcast.lullaby)
		elseif string.find(spell.english,'Etude') then equip(sets.midcast.Etude)
        end
		
    Daurdabla_Index = 2


    timer_reg = {}
	
    pianissimo_cycle = false
end

function pretarget(spell)
    if spell.type == 'BardSong' and spell.target.type and spell.target.type == 'PLAYER' and not buffactive.pianissimo and not spell.target.charmed and not pianissimo_cycle then
        cancel_spell()
        pianissimo_cycle = true
        send_command('input /ja "Pianissimo" <me>;wait 1.5;input /ma "'..spell.name..'" '..spell.target.name..';')
        return
    end
    if spell.name ~= 'Pianissimo' then
        pianissimo_cycle = false
    end
end

	if string.find(spell.english,'Lullaby') then
        send_command('@timers c "'..spell.english..' ['..spell.target.name..']" 60 down spells/00220.png')
    elseif string.find(spell.english,'Lullaby II') then
        send_command('@timers c "'..spell.english..' ['..spell.target.name..']" 120 down spells/00220.png')
    end
        end
    end
end

function self_command(command)
	if command == 'Daurdabla' then 
		--if buffactive['Pianissimo'] then
			
		--else
			Daur()
		--end

----5曲 无基曲情况 NT10分钟 3攻1速 STR----	口令：//console gs c GGMHS
	    elseif command == 'GGMHS' then
		send_command('@input /ja "Clarion Call" <me>;wait 2;input /ja "Troubadour" <me>;wait 2;input /ja "Nightingale" <me>;wait 2;input /ma "Valor Minuet V" <me>;wait 4;input /ma "Valor Minuet IV" <me>;wait 4;input /ma "Army\'s Paeon" <me>;wait 4;input /ma "Army\'s Paeon II" <me>;wait 4;input /ma "Army\'s Paeon III" <me>;wait 4;input /ma "Valor Minuet III" <me>;wait 4;input /ja "Marcato" <me>;wait 2;input /ma "Honor March" <me>;wait 4;input /ma "Herculean Etude" <me>;gs c DumsongDone')
		
----5曲 无基曲情况 NT10分钟 2攻 2速 1准----	口令：//console gs c GGHVM
	    elseif command == 'GGHVM' then
		send_command('@input /ja "Clarion Call" <me>;wait 2;input /ja "Troubadour" <me>;wait 2;input /ja "Nightingale" <me>;wait 2;input /ma "Valor Minuet V" <me>;wait 4;input /ma "Valor Minuet IV" <me>;wait 4;input /ma "Army\'s Paeon" <me>;wait 4;input /ma "Army\'s Paeon II" <me>;wait 4;input /ma "Army\'s Paeon III" <me>;wait 4;input /ma "Victory March" <me>;wait 4;input /ja "Marcato" <me>;wait 2;input /ma "Honor March" <me>;wait 4;input /ma "Blade Madrigal" <me>;gs c DumsongDone')

----4曲 无基曲情况 NT10分钟 攻 攻 V速 强化H速 ---	    口令：//console gs c ggmh
        elseif command == 'ggmh' then
		send_command('@input /ja "Troubadour" <me>;wait 2;input /ja "Nightingale" <me>;wait 2;input /ma "Valor Minuet V" <me>;wait 4;input /ma "Valor Minuet IV" <me>;wait 4;input /ma "Army\'s Paeon" <me>;wait 4;input /ma "Army\'s Paeon II" <me>;wait 4;input /ma "Army\'s Paeon III" <me>;wait 4;input /ma "Victory March" <me>;wait 4;input /ja "Marcato" <me>;wait 2;input /ma "Honor March" <me>;gs c DumsongDone')

----5曲 无基曲情况 NT10分钟 攻 攻 攻 强化H速 STR----	口令：//console gs c GGGHSTR
	    elseif command == 'GGGHSTR' then
		send_command('@input /ja "Clarion Call" <me>;wait 2;input /ja "Troubadour" <me>;wait 2;input /ja "Nightingale" <me>;wait 2;input /ma "Valor Minuet V" <me>;wait 4;input /ma "Valor Minuet IV" <me>;wait 4;input /ma "Army\'s Paeon" <me>;wait 4;input /ma "Army\'s Paeon II" <me>;wait 4;input /ma "Army\'s Paeon III" <me>;wait 4;input /ma "Valor Minuet III" <me>;wait 4;input /ja "Marcato" <me>;wait 2;input /ma "Honor March" <me>;wait 4;input /ma "Herculean Etude" <me>;gs c DumsongDone')

----4曲 无基曲情况 NT10分钟 攻 攻 STR 强化H速----	     口令：//console gs c ggstrh
	    elseif command == 'ggstrh' then
		send_command('@input /ja "Troubadour" <me>;wait 2;input /ja "Nightingale" <me>;wait 2;input /ma "Valor Minuet V" <me>;wait 4;input /ma "Valor Minuet IV" <me>;wait 4;input /ma "Army\'s Paeon II" <me>;wait 4;input /ma "Army\'s Paeon III" <me>;wait 4;input /ma "Herculean Etude" <me>;wait 4;input /ja "Marcato" <me>;wait 2;input /ma "Honor March" <me>;wait 4;gs c DumsongDone')

----5曲 无基曲情况 NT10分钟 攻 攻 STR 强化H速 攻----	口令：//console gs c GGSTRHG
	    elseif command == 'GGSTRHG' then
		send_command('@input /ja "Clarion Call" <me>;wait 2;input /ja "Troubadour" <me>;wait 2;input /ja "Nightingale" <me>;wait 2;input /ma "Valor Minuet V" <me>;wait 4;input /ma "Valor Minuet IV" <me>;wait 4;input /ma "Army\'s Paeon" <me>;wait 4;input /ma "Army\'s Paeon II" <me>;wait 4;input /ma "Army\'s Paeon III" <me>;wait 4;input /ma "Valor Minuet III" <me>;wait 4;input /ja "Marcato" <me>;wait 2;input /ma "Honor March" <me>;wait 4;input /ma "Herculean Etude" <me>;gs c DumsongDone')

----4曲 无基曲情况 NT10分钟 攻 攻 攻 强化H速----	    口令：//console gs c gggh
	    elseif command == 'gggh' then
		send_command('@input /ja "Troubadour" <me>;wait 2;input /ja "Nightingale" <me>;wait 2;input /ma "Valor Minuet V" <me>;wait 4;input /ma "Valor Minuet IV" <me>;wait 4;input /ma "Army\'s Paeon II" <me>;wait 4;input /ma "Army\'s Paeon III" <me>;wait 4;input /ma "Valor Minuet III" <me>;wait 4;input /ja "Marcato" <me>;wait 2;input /ma "Honor March" <me>;wait 4;gs c DumsongDone')

----5曲 无基曲情况 NT10分钟 攻 攻 攻 强化H速 B准确----	口令：//console gs c GGGHZHUN
	    elseif command == 'GGGHZHUN' then
		send_command('@input /ja "Clarion Call" <me>;wait 2;input /ja "Troubadour" <me>;wait 2;input /ja "Nightingale" <me>;wait 2;input /ma "Valor Minuet V" <me>;wait 4;input /ma "Valor Minuet IV" <me>;wait 4;input /ma "Army\'s Paeon" <me>;wait 4;input /ma "Army\'s Paeon II" <me>;wait 4;input /ma "Army\'s Paeon III" <me>;wait 4;input /ma "Valor Minuet III" <me>;wait 4;input /ja "Marcato" <me>;wait 2;input /ma "Honor March" <me>;wait 4;input /ma "Blade Madrigal" <me>;gs c DumsongDone')

----4曲 无基曲情况 NT10分钟 攻 攻 B准确 强化H速 ----	口令：//console gs c ggzh
        elseif command == 'ggzh' then
		send_command('@input /ja "Troubadour" <me>;wait 2;input /ja "Nightingale" <me>;wait 2;input /ma "Valor Minuet V" <me>;wait 4;input /ma "Valor Minuet IV" <me>;wait 4;input /ma "Army\'s Paeon II" <me>;wait 4;input /ma "Army\'s Paeon" <me>;wait 4;input /ma "Blade Madrigal" <me>;wait 4;input /ja "Marcato" <me>;wait 2;input /ma "Honor March" <me>;gs c DumsongDone')
	
----5曲 无基曲情况 NT10分钟 閃躲 閃躲 V速 强化H速 防御5 ----	口令：//console gs c JAtt
	    elseif command == 'JAtt' then
		send_command('@input /ja "Clarion Call" <me>;wait 2;input /ja "Troubadour" <me>;wait 2;input /ja "Nightingale" <me>;wait 2;input /ma "Sheepfoe Mambo" <me>;wait 4;input /ma "Dragonfoe Mambo" <me>;wait 4;input /ma "Army\'s Paeon II" <me>;wait 4;input /ma "Army\'s Paeon" <me>;wait 4;input /ma "Army\'s Paeon III" <me>;wait 4;input /ma "Victory March" <me>;wait 4;input /ja "Marcato" <me>;wait 2;input /ma "Honor March" <me>;wait 4;input /ma "Knight\'s Minne V" <me>;gs c DumsongDone')
        
----4曲 有基曲情况  等待8秒 普通曲 V速  攻5  B准  H速 ----      口令：//console gs c MGZM
	    elseif command == 'MGZM' then
		send_command('@input /ma "Victory March" <me>;wait 8;input /ma "Valor Minuet V" <me>;wait 8;input /ma "Blade Madrigal" <me>;wait 8;input /ma "Honor March" <me>;gs c DumsongDone')

----4曲 有基曲情况  等待8秒 普通曲 B准  S准  V速  H速 ----      口令：//console gs c ZZMM
	    elseif command == 'ZZMM' then
		send_command('@input /ma "Blade Madrigal" <me>;wait 8;input /ma "Sword Madrigal" <me>;wait 8;input /ma "Victory March" <me>;wait 8;input /ma "Honor March" <me>;gs c DumsongDone')

----4曲 有基曲情况  等待8秒 普通曲 攻4  攻5  B准  H速 ----      口令：//console gs c ggzs
        elseif command == 'ggzs' then
                send_command('@input /ma "Valor Minuet IV" <me>;wait 8;input /ma "Valor Minuet V" <me>;wait 8;input /ma "Blade Madrigal" <me>;wait 8;input /ma "Honor March" <me>;gs c DumsongDone')


----4曲 有基曲情况  等待8秒 普通曲 H弓准  A弓准   攻4  攻5  ----      口令：//console gs c rngs
	    elseif command == 'rngs' then
		send_command('@input /ma "Hunter\'s Prelude" <me>;wait 8;input /ma "Archer\'s Prelude" <me>;wait 8;input /ma "Valor Minuet V" <me>;wait 8;input /ma "Valor Minuet IV" <me>;gs c DumsongDone')
        
----4曲 有基曲情况  等待8秒 普通曲 MP3  MP2  V速  H速  ----      口令：//console gs c Ball2m2
	    elseif command == 'Ball2m2' then
		send_command('@input /ma "Mage\'s Ballad III" <me>;wait 8;input /ma "Mage\'s Ballad II" <me>;wait 8;gs c Daur;wait 8;gs c Daur;wait 8;input /ma "Victory March" <me>;wait 8;input /ma "Honor March" <me>;gs c DumsongDone')

----4曲 基曲  等待8秒 普通曲 HP4 HP3 HP2 HP  ----      口令：//console gs c 4HP
	    elseif command == '4HP' then
		send_command('@input /ma "Army\'s Paeon IV" <me>;wait 5;input /ma "Army\'s Paeon III" <me>;wait 5;input /ma "Army\'s Paeon II" <me>;wait 5;input /ma "Army\'s Paeon" <me>;gs c DumsongDone')

	elseif command == 'Dumsong' then
		send_command('@gs c Daur;wait 8;gs c Daur;wait 8;gs c Daur;wait 8;gs c Daur;gs c DumsongDone')
	elseif command == 'DumsongDone' then
		Dumsong = 2
	elseif command == 'Daur' then
		Daur()
	end
end

]]
