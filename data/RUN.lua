--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
-- __________.__                                ________                          __               .__.__  __      __  .__    .__           _____.__.__              
-- \______   |  |   ____ _____    ______ ____   \______ \   ____     ____   _____/  |_    ____   __| _|___/  |_  _/  |_|  |__ |__| ______ _/ ____|__|  |   ____      
--  |     ___|  | _/ __ \\__  \  /  ____/ __ \   |    |  \ /  _ \   /    \ /  _ \   __\ _/ __ \ / __ ||  \   __\ \   __|  |  \|  |/  ___/ \   __\|  |  | _/ __ \     
--  |    |   |  |_\  ___/ / __ \_\___ \\  ___/   |    `   (  <_> ) |   |  (  <_> |  |   \  ___// /_/ ||  ||  |    |  | |   Y  |  |\___ \   |  |  |  |  |_\  ___/     
--  |____|   |____/\___  (____  /____  >\___  > /_______  /\____/  |___|  /\____/|__|    \___  \____ ||__||__|    |__| |___|  |__/____  >  |__|  |__|____/\___  > /\ 
--                     \/     \/     \/     \/          \/              \/                   \/     \/                      \/        \/                      \/  \/ 
--
--	Please do not edit this file!							Please do not edit this file!							Please do not edit this file!
--
--	Editing this file will cause you to be unable to use Github Desktop to update!
--
--	Any changes you wish to make in this file you should be able to make by overloading. That is Re-Defining the same variables or functions in another file, by copying and
--	pasting them to a file that is loaded after the original file, all of my library files, and then job files are loaded first.
--	The last files to load are the ones unique to you. User-Globals, Charactername-Globals, Charactername_Job_Gear, in that order, so these changes will take precedence.
--
--	You may wish to "hook" into existing functions, to add functionality without losing access to updates or fixes I make, for example, instead of copying and editing
--	status_change(), you can instead use the function user_status_change() in the same manner, which is called by status_change() if it exists, most of the important 
--  gearswap functions work like this in my files, and if it's unique to a specific job, user_job_status_change() would be appropriate instead.
--
--  Variables and tables can be easily redefined just by defining them in one of the later loaded files: autofood = 'Miso Ramen' for example.
--  States can be redefined as well: state.HybridMode:options('Normal','PDT') though most of these are already redefined in the gear files for editing there.
--	Commands can be added easily with: user_self_command(commandArgs, eventArgs) or user_job_self_command(commandArgs, eventArgs)
--
--	If you're not sure where is appropriate to copy and paste variables, tables and functions to make changes or add them:
--		User-Globals.lua - 			This file loads with all characters, all jobs, so it's ideal for settings and rules you want to be the same no matter what.
--		Charactername-Globals.lua -	This file loads with one character, all jobs, so it's ideal for gear settings that are usable on all jobs, but unique to this character.
--		Charactername_Job_Gear.lua-	This file loads only on one character, one job, so it's ideal for things that are specific only to that job and character.
--
--
--	If you still need help, feel free to contact me on discord or ask in my chat for help: https://discord.gg/ug6xtvQ
--  !Please do NOT message me in game about anything third party related, though you're welcome to message me there and ask me to talk on another medium.
--
--  Please do not edit this file!							Please do not edit this file!							Please do not edit this file!
-- __________.__                                ________                          __               .__.__  __      __  .__    .__           _____.__.__              
-- \______   |  |   ____ _____    ______ ____   \______ \   ____     ____   _____/  |_    ____   __| _|___/  |_  _/  |_|  |__ |__| ______ _/ ____|__|  |   ____      
--  |     ___|  | _/ __ \\__  \  /  ____/ __ \   |    |  \ /  _ \   /    \ /  _ \   __\ _/ __ \ / __ ||  \   __\ \   __|  |  \|  |/  ___/ \   __\|  |  | _/ __ \     
--  |    |   |  |_\  ___/ / __ \_\___ \\  ___/   |    `   (  <_> ) |   |  (  <_> |  |   \  ___// /_/ ||  ||  |    |  | |   Y  |  |\___ \   |  |  |  |  |_\  ___/     
--  |____|   |____/\___  (____  /____  >\___  > /_______  /\____/  |___|  /\____/|__|    \___  \____ ||__||__|    |__| |___|  |__/____  >  |__|  |__|____/\___  > /\ 
--                     \/     \/     \/     \/          \/              \/                   \/     \/                      \/        \/                      \/  \/ 
--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

-------------------------------------------------------------------------------------------------------------------
-- Setup functions for this job.  Generally should not be modified.
-------------------------------------------------------------------------------------------------------------------

-- Initialization function for this job file.
function get_sets()

	-- Load and initialize the include file.
	include('Sel-Include.lua')
end

-- Setup vars that are user-independent.
function job_setup()

	state.Buff['Aftermath: Lv.3'] = buffactive['Aftermath: Lv.3'] or false
	state.Buff['Valiance'] = buffactive['Valiance'] or false
	state.Buff['Vallation'] = buffactive['Vallation'] or false
	state.Buff['Embolden'] = buffactive['Embolden'] or false
	state.Buff['Elemental Sforzo'] = buffactive['Elemental Sforzo'] or false


    state.Buff.Hasso = buffactive.Hasso or false
    state.Buff.Seigan = buffactive.Seigan or false
	state.Stance = M{['description']='Stance','Hasso','Seigan','None'}
    state.Steps = M{['description']='Current Step', 'Quickstep','Box Step','Stutter Step'}
	state.SrodaBelt = M(false, 'SrodaBelt')
    state.RP = M(false, "Reinforcement Points Mode")
	state.WeaponLock = M(false, 'Weapon Lock')
    state.HippoMode = M(false, "hippoMode")
    state.AutoCureMode = M(true, 'Auto Cure Mode')

	rayke_duration = 49
    gambit_duration = 96
	--autows = 'Resolution'
	autofood = 'Miso Ramen'

	Haste = 0
	DW_needed = 0
	DW = false
	determine_haste_group()
	update_combat_form()  

	update_melee_groups()
	init_job_states({"Capacity","AutoRuneMode","AutoTrustMode","AutoTankMode","AutoWSMode","AutoShadowMode","AutoFoodMode","AutoNukeMode","AutoStunMode","AutoDefenseMode","HippoMode","SrodaBelt","AutoMedicineMode"},{"AutoBuffMode","AutoSambaMode","Weapons","OffenseMode","WeaponskillMode","Stance","IdleMode","Passive","RuneElement","ElementalMode","CastingMode","PhysicalDefenseMode","MagicalDefenseMode","ResistDefenseMode","TreasureMode",})
end

buff_spell_lists = {
	Auto = {--Options for When are: Always, Engaged, Idle, OutOfCombat, Combat
		{Name='Crusade',	Buff='Enmity Boost',	SpellID=476,	When='Combat'},
		{Name='Temper',		Buff='Multi Strikes',	SpellID=493,	When='Engaged'},
		{Name='Phalanx',	Buff='Phalanx',			SpellID=106,	When='Always'},
		--{Name='Refresh',	Buff='Refresh',			SpellID=109,	When='Idle'},
	},
	Melee = {--Options for When are: Always, Engaged, Idle, OutOfCombat, Combat
	{Name='Temper',		Buff='Multi Strikes',	SpellID=493,	When='Engaged'},
	{Name='Phalanx',	Buff='Phalanx',			SpellID=106,	When='Always'},
	--{Name='Refresh',	Buff='Refresh',			SpellID=109,	When='Idle'},
    },
	Tank = {
		{Name='Crusade',	Buff='Enmity Boost',	SpellID=476,	When='Always'},
		{Name='Cocoon',		Buff='Defense Boost',	SpellID=547,	When='Always'},
		{Name='Haste',		Buff='Haste',			SpellID=57,		When='Always'},
		--{Name='Refresh',	Buff='Refresh',			SpellID=109,	When='Always'},
		{Name='Phalanx',	Buff='Phalanx',			SpellID=106,	When='Always'},
	},
	Aminon = {
		{Name='Crusade',	Buff='Enmity Boost',	SpellID=476,	When='Always'},
		{Name='Aquaveil',	Buff='Aquaveil',		SpellID=55,		When='Always'},
		{Name='Stoneskin',	Buff='Stoneskin',		SpellID=54,		When='Always'},
		{Name='Phalanx',	Buff='Phalanx',			SpellID=106,	When='Always'},
		{Name='Regen IV',	Buff='Regen',			SpellID=477,	When='Always'},
	},
	Sortie = {
		{Name='Crusade',	Buff='Enmity Boost',	SpellID=476,	When='Always'},
		{Name='Temper',		Buff='Multi Strikes',	SpellID=493,	When='Engaged'},
		{Name='Haste',		Buff='Haste',			SpellID=57,		When='Always'},
		{Name='Aquaveil',	Buff='Aquaveil',		SpellID=55,		When='Always'},
		{Name='Stoneskin',	Buff='Stoneskin',		SpellID=54,		When='Always'},
		{Name='Phalanx',	Buff='Phalanx',			SpellID=106,	When='Always'},
		{Name='Regen IV',	Buff='Regen',			SpellID=477,	When='Always'},
	},
	Full = {
		{Name='Crusade',	Buff='Enmity Boost',	SpellID=476,	When='Always'},
		{Name='Temper',		Buff='Multi Strikes',	SpellID=493,	When='Engaged'},
		{Name='Haste',		Buff='Haste',			SpellID=57,		When='Always'},
		{Name='Refresh',	Buff='Refresh',			SpellID=109,	When='Idle'},
		{Name='Aquaveil',	Buff='Aquaveil',		SpellID=55,		When='Always'},
		{Name='Stoneskin',	Buff='Stoneskin',		SpellID=54,		When='Always'},
		{Name='Blink',		Buff='Blink',			SpellID=53,		When='Always'},
		{Name='Phalanx',	Buff='Phalanx',			SpellID=106,	When='Always'},
		{Name='Regen IV',	Buff='Regen',			SpellID=477,	When='Always'},
	},
	Default = {
		{Name='Crusade',	Buff='Enmity Boost',	SpellID=476,	Reapply=false},
		{Name='Temper',		Buff='Multi Strikes',	SpellID=493,	Reapply=false},
		{Name='Haste',		Buff='Haste',			SpellID=57,		Reapply=false},
		{Name='Refresh',	Buff='Refresh',			SpellID=109,	Reapply=false},
		{Name='Phalanx',	Buff='Phalanx',			SpellID=106,	Reapply=false},
	},
	
	Tank = {
		{Name='Crusade',	Buff='Enmity Boost',	SpellID=476,	Reapply=false},
		{Name='Cocoon',		Buff='Defense Boost',	SpellID=547,	Reapply=false},
		{Name='Haste',		Buff='Haste',			SpellID=57,		Reapply=false},
		{Name='Refresh',	Buff='Refresh',			SpellID=109,	Reapply=false},
		{Name='Phalanx',	Buff='Phalanx',			SpellID=106,	Reapply=false},
	},
	
	Full = {
		{Name='Crusade',	Buff='Enmity Boost',	SpellID=476,	Reapply=false},
		{Name='Temper',		Buff='Multi Strikes',	SpellID=493,	Reapply=false},
		{Name='Haste',		Buff='Haste',			SpellID=57,		Reapply=false},
		{Name='Refresh',	Buff='Refresh',			SpellID=109,	Reapply=false},
		{Name='Aquaveil',	Buff='Aquaveil',		SpellID=55,		Reapply=false},
		{Name='Stoneskin',	Buff='Stoneskin',		SpellID=54,		Reapply=false},
		{Name='Blink',		Buff='Blink',			SpellID=53,		Reapply=false},
		{Name='Phalanx',	Buff='Phalanx',			SpellID=106,	Reapply=false},
		{Name='Regen IV',	Buff='Regen',			SpellID=477,	Reapply=false},
	},
	Melee = {
		{Name='Temper',		Buff='Multi Strikes',	SpellID=493,	Reapply=false},
		{Name='Haste',		Buff='Haste',			SpellID=57,		Reapply=false},
		{Name='Refresh',	Buff='Refresh',			SpellID=109,	Reapply=false},
		{Name='Aquaveil',	Buff='Aquaveil',		SpellID=55,		Reapply=false},
		{Name='Stoneskin',	Buff='Stoneskin',		SpellID=54,		Reapply=false},
		{Name='Blink',		Buff='Blink',			SpellID=53,		Reapply=false},
		{Name='Phalanx',	Buff='Phalanx',			SpellID=106,	Reapply=false},
		{Name='Regen IV',	Buff='Regen',			SpellID=477,	Reapply=false},
	},
}

-------------------------------------------------------------------------------------------------------------------
-- Job-specific hooks for standard casting events.
-------------------------------------------------------------------------------------------------------------------
-- Set eventArgs.handled to true if we don't want any automatic gear equipping to be done.
-- Set eventArgs.useMidcastGear to true if we want midcast gear equipped on precast.

function job_filter_pretarget(spell, spellMap, eventArgs)
	
	local abil_recasts = windower.ffxi.get_ability_recasts()

	if party.count ~= 1 and spell.skill == 'Enhancing Magic' and (spell.english:contains('storm')) and get_current_stratagem_count() > 0 then
		cast_delay(1.1)
		windower.chat.input('/ja "Accession" <me>')
		add_to_chat(204, 'Stratagem Charges Available: ['..get_current_stratagem_count()..']~~~')
		send_command('@input /echo <recast=Stratagems>')
		send_command('@input /p <recast=Stratagems>')
	
	
	end
	
	if party.count ~= 1 and (spell.english == 'Sneak' or spell.english == 'Invisible') and get_current_stratagem_count() > 0 then
		cast_delay(1.1)
		windower.chat.input('/ja "Accession" <me>')
		add_to_chat(204, 'Stratagem Charges Available: ['..get_current_stratagem_count()..']~~~')
		send_command('@input /echo <recast=Stratagems>')
		send_command('@input /p <recast=Stratagems>')
		if not midaction() then
			job_update()
		end
	end

end
function job_pretarget(spell, spellMap, eventArgs)

end
function job_filter_precast(spell, spellMap, eventArgs)

	if spell.english == 'Valiance' then
		local abil_recasts = windower.ffxi.get_ability_recasts()
		if abil_recasts[113] > 0 and not state.Buff['Valiance'] and abil_recasts[23] < latency then
			eventArgs.cancel = true
			send_command('@input /ja "Vallation" <me>')
		end
	end
	
end

function job_precast(spell, spellMap, eventArgs)

	if spell.english == 'Vivacious Pulse' then
		equip(sets.precast.JA['Vivacious Pulse'][state.RuneElement.value])
		return
	end

	if spell.type == 'WeaponSkill' and state.AutoBuffMode.value ~= 'Off' and not state.Buff['SJ Restriction'] then
		local abil_recasts = windower.ffxi.get_ability_recasts()
		if player.sub_job == 'SAM' and player.tp > 1850 and abil_recasts[140] < latency then
			eventArgs.cancel = true
			windower.chat.input('/ja "Sekkanoki" <me>')
			windower.chat.input:schedule(1,'/ws "'..spell.english..'" '..spell.target.raw..'')
			tickdelay = os.clock() + 1.25
			return
		elseif player.sub_job == 'SAM' and abil_recasts[134] < latency then
			eventArgs.cancel = true
			windower.chat.input('/ja "Meditate" <me>')
			windower.chat.input:schedule(1,'/ws "'..spell.english..'" '..spell.target.raw..'')
			tickdelay = os.clock() + 1.25
			return
		end
	end
	
end

function job_post_precast(spell, spellMap, eventArgs)

	if spell.type == 'WeaponSkill' then
		local WSset = standardize_set(get_precast_set(spell, spellMap))
		local wsacc = check_ws_acc()
		
		if (WSset.ear1 == "Moonshade Earring" or WSset.ear2 == "Moonshade Earring") then
			-- Replace Moonshade Earring if we're at cap TP
			if get_effective_player_tp(spell, WSset) > 3200 then
				if wsacc:contains('Acc') and not buffactive['Sneak Attack'] and sets.AccMaxTP then
					equip(sets.AccMaxTP[spell.english] or sets.AccMaxTP)
				elseif sets.MaxTP then
					equip(sets.MaxTP[spell.english] or sets.MaxTP)
				else
				end
			end
		end
	elseif spell.english == 'Lunge' or spell.english == 'Swipe' then
        if weather_rune_match() then
			if item_available('Hachirin-no-Obi') then
				equip({waist="Hachirin-no-Obi"})
			end
        end
		if spell.element and sets.element[spell.element] then
			equip(sets.element[spell.element])
		end
    end
	
end

-- Run after the default midcast() is done.
-- eventArgs is the same one used in job_midcast, in case information needs to be persisted.
function job_post_midcast(spell, spellMap, eventArgs)
    if spell.skill == 'Enhancing Magic' and state.Buff.Embolden and sets.buff.Embolden then
        equip(sets.buff.Embolden)
    end
	if (spellMap == 'Cure' or spellMap == 'Regen') then
        if state.SrodaBelt.value then
            equip({waist="Sroda Belt"})
        end
    end
end

function job_filter_aftercast(spell, spellMap, eventArgs)
    if spell.name == 'Rayke' and not spell.interrupted then
        send_command('@timers c "Rayke ['..spell.target.name..']" '..rayke_duration..' down spells/00136.png')
        send_command('wait '..rayke_duration..';input /p <t> [Rayke just wore off!];')
        send_command('@input /p  >>> '..auto_translate('Rayke')..' on ['..spell.target.name..']. Second left: '..rayke_duration..'')
    elseif spell.name == 'Gambit' and not spell.interrupted then
        send_command('@timers c "Gambit ['..spell.target.name..']" '..gambit_duration..' down spells/00136.png')
        send_command('wait '..gambit_duration..';input /p <t> [Gambit just wore off!];')
        send_command('@input /p  >>> '..auto_translate('Gambit')..' on ['..spell.target.name..']. Second left: '..gambit_duration..'')
    end
	if (player.in_combat or being_attacked) and spellMap == 'Cure' and spell.interrupted then
		state.CastingMode:set('SIRD')
		--send_command('gs c set state.CastingMode.value SIRD')
		send_command('gs c update')
		tickdelay = os.clock() + 1.1
	end
	--[[ 
	elseif not data.areas.cities:contains(world.area) and not (player.in_combat or being_attacked) then
		state.CastingMode:set('Duration')
		send_command('gs c update')
		tickdelay = os.clock() + 1.1
    end
	]]
end

function job_aftercast(spell)
    if spell.name == 'Rayke' and not spell.interrupted then
        send_command('@timers c "Rayke ['..spell.target.name..']" '..rayke_duration..' down spells/00136.png')
        send_command('wait '..rayke_duration..';input /p <t> [Rayke just wore off!];')
        send_command('@input /p  >>> Rayke on ['..spell.target.name..']. Second left: '..rayke_duration..'')
    elseif spell.name == 'Gambit' and not spell.interrupted then
        send_command('@timers c "Gambit ['..spell.target.name..']" '..gambit_duration..' down spells/00136.png')
        send_command('wait '..gambit_duration..';input /p <t> [Gambit just wore off!];')
        send_command('@input /p  >>> Gambit on ['..spell.target.name..']. Second left: '..gambit_duration..'')
    end
end

function job_buff_change(buff, gain)
	update_melee_groups()
	if buff == 'Embolden' then
        if gain then
            equip(sets.Embolden)
            disable('head','legs','back')
        else
            enable('head','legs','back')
            status_change(player.status)
        end
    end
end

-------------------------------------------------------------------------------------------------------------------
-- Customization hooks for idle and melee sets, after they've been automatically constructed.
-------------------------------------------------------------------------------------------------------------------

-- Modify the default melee set after it was constructed.
function job_customize_melee_set(meleeSet)

	if buffactive['Battuta'] and sets.buff.Battuta then 
		meleeSet = set_combine(meleeSet, sets.buff.Battuta)
	end
    if state.RP.current == 'on' then
        equip(sets.RP)
        disable('neck')
    else
        enable('neck')
    end
    return meleeSet

end

function job_customize_defense_set(defenseSet)
    if state.ExtraDefenseMode.value ~= 'None' and state.DefenseMode.value ~= 'None' then
        defenseSet = set_combine(defenseSet, sets[state.ExtraDefenseMode.value])
    end

	if buffactive['Battuta'] and sets.buff.Battuta and player.status == 'Engaged' and state.DefenseMode.value == 'Physical' then 
		defenseSet = set_combine(defenseSet, sets.buff.Battuta)
	end
	if state.RP.current == 'on' then
        equip(sets.RP)
        disable('neck')
    else
        enable('neck')
    end
    return defenseSet
end

-- Modify the default idle set after it was constructed.
function job_customize_idle_set(idleSet)
    if player.mpp < 51 and (state.IdleMode.value == 'Normal' or state.IdleMode.value:contains('Sphere')) then
		if sets.latent_refresh then
			idleSet = set_combine(idleSet, sets.latent_refresh)
		end
		
		if (state.Weapons.value == 'None' or state.UnlockWeapons.value) and idleSet.main then
			local main_table = get_item_table(idleSet.main)

			if  main_table and (main_table.skill == 12 or main_table.skill == 4) and sets.latent_refresh_grip then
				idleSet = set_combine(idleSet, sets.latent_refresh_grip)
			end
		end
    end
    if state.HippoMode.value == true then 
        idleSet = set_combine(idleSet, {feet="Hippo. Socks +1"})
    end
	if state.RP.current == 'on' then
        equip(sets.RP)
        disable('neck')
    else
        enable('neck')
    end
    return idleSet
end

function job_update(cmdParams, eventArgs)
	update_melee_groups()
	
	if player.sub_job ~= 'SAM' and state.Stance.value ~= "None" then
		state.Stance:set("None")
	end
end

-------------------------------------------------------------------------------------------------------------------
-- General hooks for other events.
-------------------------------------------------------------------------------------------------------------------

-- Handle notifications of general user state change.
function job_state_change(stateField, newValue, oldValue)
    classes.CustomDefenseGroups:clear()
    classes.CustomDefenseGroups:append(state.ExtraDefenseMode.current)
    classes.CustomMeleeGroups:clear()
    classes.CustomMeleeGroups:append(state.ExtraDefenseMode.current)
	if state.WeaponLock.value == true then
        disable('main','sub')
    else
        enable('main','sub')
    end
end


function user_status_change(newStatus, oldStatus, eventArgs)
	
	local abil_recasts = windower.ffxi.get_ability_recasts()
	local spell_recasts = windower.ffxi.get_spell_recasts()

 
	if not buffactive['Elemental Sforzo'] and (player.in_combat or being_attacked) and  player.hpp < 25 and abil_recasts[0] < latency then
		 windower.chat.input('/ja "Elemental Sforzo" <me>')
		 tickdelay = os.clock() + 1.1
		 return true
 
	elseif player.sub_job == 'WAR' and not buffactive.Defender and (player.in_combat or being_attacked) and player.hpp < 25 and abil_recasts[3] < latency then
		 windower.chat.input('/ja "Defender" <me>')
		 tickdelay = os.clock() + 1.1
		 return true
	elseif player.sub_job == 'PLD' and (player.in_combat or being_attacked) and not buffactive.Sentinel and player.hpp < 25 and abil_recasts[75] < latency then
		windower.chat.input('/ja "Sentinel" <me>')
		tickdelay = os.clock() + 1.1
		return true
	elseif player.sub_job == 'PLD' and (player.in_combat or being_attacked) and not buffactive['Holy Circle'] and player.hpp < 42 and abil_recasts[74] < latency then
		 windower.chat.input('/ja "Holy Circle" <me>')
		 tickdelay = os.clock() + 1.1
		 return true

	
    elseif state.NeverDieMode.value or state.AutoCureMode.value then 
		if being_attacked and player.hpp < 85 and abil_recasts[242] < latency then 
			windower.chat.input('/ja "Vivacious Pulse" <me>')
			tickdelay = os.clock() + 1.1
	    elseif player.sub_job == 'SCH' and player.hpp < 85  and being_attacked and spell_recasts[4] < spell_latency then 
			windower.chat.input('/ma "Cure IV" <me>')

			tickdelay = os.clock() + 1.1
		    
		end
	end

 
end
-------------------------------------------------------------------------------------------------------------------
-- User code that supplements self-commands.
-------------------------------------------------------------------------------------------------------------------
function update_combat_form()
    if DW == true then
        state.CombatForm:set('DW')
    elseif DW == false then
        state.CombatForm:reset()
    end
end
function determine_haste_group()
    classes.CustomMeleeGroups:clear()
    if DW == true then
        if DW_needed <= 11 then
            classes.CustomMeleeGroups:append('MaxHaste')
        elseif DW_needed > 11 and DW_needed <= 21 then
            classes.CustomMeleeGroups:append('MidHaste')
        elseif DW_needed > 21 and DW_needed <= 27 then
            classes.CustomMeleeGroups:append('MidHaste')
        elseif DW_needed > 27 and DW_needed <= 37 then
            classes.CustomMeleeGroups:append('LowHaste')
        elseif DW_needed > 37 then
            classes.CustomMeleeGroups:append('LowHaste')
        end
    end
end

function gearinfo(commandArgs, eventArgs)
    if commandArgs[1] == 'gearinfo' then
        if type(tonumber(commandArgs[2])) == 'number' then
            if tonumber(commandArgs[2]) ~= DW_needed then
            DW_needed = tonumber(commandArgs[2])
            DW = true
            end
        elseif type(commandArgs[2]) == 'string' then
            if commandArgs[2] == 'false' then
                DW_needed = 0
                DW = false
            end
        end
        if type(tonumber(commandArgs[3])) == 'number' then
            if tonumber(commandArgs[3]) ~= Haste then
                Haste = tonumber(commandArgs[3])
            end
        end
        if not midaction() then
            job_update()
        end
    end
end
function job_handle_equipping_gear(playerStatus, eventArgs)
    determine_haste_group()
	update_combat_form()
end
function job_self_command(commandArgs, eventArgs)
	gearinfo(commandArgs, eventArgs)

	if commandArgs[1]:lower() == 'smartcure' then
		handle_smartcure(commandArgs)
		eventArgs.handled = true
	elseif commandArgs[1]:lower() == 'elemental' then
		handle_elemental(commandArgs)
		eventArgs.handled = true
	end
	if commandArgs[1]:lower() == 'subjobenmity' then

		if player.target.type ~= "MONSTER" then
			add_to_chat(123,'Abort: You are not targeting a monster.')
			return
	
		elseif player.sub_job == 'BLU' then
			local spell_recasts = windower.ffxi.get_spell_recasts()
					
			if spell_recasts[584] < spell_latency then
				windower.chat.input('/ma "Geist Wall" <t>')
			--elseif spell_recasts[598] < spell_latency then
			--	windower.chat.input('/ma "Soporific" <t>')
			--elseif spell_recasts[605] < spell_latency then
			--	windower.chat.input('/ma "Sheep Song" <t>')
		    elseif spell_recasts[575] < spell_latency then
			    windower.chat.input('/ma "Jettatura" <t>')	
		    --elseif spell_recasts[537] < spell_latency then
				--windower.chat.input('/ma "Stinking Gas" <t>')
			--elseif spell_recasts[592] < spell_latency then
				--windower.chat.input('/ma "Blank Gaze" <t>')
			elseif not check_auto_tank_ws() then
				if not state.AutoTankMode.value then add_to_chat(123,'All Enmity Blue Magic on cooldown.') end
			end
			
		elseif player.sub_job == 'DRK' then
			local abil_recasts = windower.ffxi.get_ability_recasts()
			local spell_recasts = windower.ffxi.get_spell_recasts()
			
			if (state.HybridMode.value ~= 'Normal' or state.DefenseMode.value ~= 'None')  and buffactive['Souleater'] then
				send_command('cancel souleater')
			end
			
			if (state.HybridMode.value ~= 'Normal' or state.DefenseMode.value ~= 'None')  and buffactive['Last Resort'] then
				send_command('cancel last resort')
			end
			
			if spell_recasts[252] < spell_latency and not silent_check_silence() then
				windower.chat.input('/ma "Stun" <t>')
			elseif abil_recasts[85] < latency then
				windower.chat.input('/ja "Souleater" <me>')
			elseif abil_recasts[87] < latency then
				windower.chat.input('/ja "Last Resort" <me>')
			elseif abil_recasts[88] < latency then
				windower.chat.input('/ja "Weapon Bash" <t>')
			elseif abil_recasts[86] < latency then
				windower.chat.input('/ja "Arcane Circle" <me>')
			elseif not check_auto_tank_ws() then
				if not state.AutoTankMode.value then add_to_chat(123,'All Enmity Dark Knight abillities on cooldown.') end
			end

		elseif player.sub_job == 'WAR' then
			local abil_recasts = windower.ffxi.get_ability_recasts()
			
			if (state.HybridMode.value ~= 'Normal' or state.DefenseMode.value ~= 'None')  and buffactive['Berserk'] then
				send_command('cancel berserk')
			end
			
			if abil_recasts[5] < latency then
				windower.chat.input('/ja "Provoke" <t>')
			elseif abil_recasts[2] < latency then
				windower.chat.input('/ja "Warcry" <me>')
			elseif abil_recasts[3] < latency then
				windower.chat.input('/ja "Defender" <me>')
			elseif abil_recasts[4] < latency then
				windower.chat.input('/ja "Aggressor" <me>')
			elseif abil_recasts[1] < latency then
				windower.chat.input('/ja "Berserk" <me>')
			elseif not check_auto_tank_ws() then
				if not state.AutoTankMode.value then add_to_chat(123,'All Enmity Warrior Job Abilities on cooldown.') end
			end
			
		elseif player.sub_job == 'DNC' then
			local abil_recasts = windower.ffxi.get_ability_recasts()
			local under3FMs = not buffactive['Finishing Move 3'] and not buffactive['Finishing Move 4'] and not buffactive['Finishing Move 5']
        
			if under3FMs then
				if abil_recasts[220] < latency then
				send_command('@input /ja "'..state.Steps.value..'" <t>')
				return
				end
			elseif abil_recasts[221] < latency then
				windower.chat.input('/ja "Animated Flourish" <t>')
				return
			elseif abil_recasts[220] < latency and not buffactive['Finishing Move 5'] then
				send_command('@input /ja "'..state.Steps.value..'" <t>')
				return
			elseif not check_auto_tank_ws() then
				if not state.AutoTankMode.value then add_to_chat(123,'Dancer job abilities not needed.') end
			end
		end

	end

end

-------------------------------------------------------------------------------------------------------------------
-- Utility functions specific to this job.
-------------------------------------------------------------------------------------------------------------------

function weather_rune_match()
    weather_rune = buffactive[data.elements.rune_of[world.weather_element] or '']
    day_rune = buffactive[data.elements.rune_of[world.day_element] or '']
    
    if weather_rune or day_rune then
		return true
	else
		return false
	end
end

-- Get a count of the number of runes of a given type
function rune_count(rune)
    local count = 0
    local current_time = os.time()
    for _,entry in pairs(rune_timers) do
        if entry.rune == rune and entry.expires > current_time then
            count = count + 1
        end
    end
    return count
end

function job_tick()
	if user_status_change() then return true end

	if check_arts() then return true end
	if check_hasso() then return true end
	if check_buff() then return true end
	if check_buffup() then return true end
	if state.AutoTankMode.value and player.in_combat and player.target.type == "MONSTER" and not moving then
		if check_flash_foil() then return true end
		windower.send_command('gs c SubJobEnmity')
		tickdelay = os.clock() + 1.5
		return true
	end
	return false
end

function check_arts()
	if (player.sub_job == 'SCH' and not (state.Buff['SJ Restriction'] or arts_active())) and (buffup ~= '' or (not data.areas.cities:contains(world.area) and (state.AutoArts.value or state.AutoBuffMode.value ~= 'Off'))) and not moving or buffactive['Sneak'] or buffactive['Invisible']  then
	
		local abil_recasts = windower.ffxi.get_ability_recasts()

		if abil_recasts[228] < latency then
			send_command('@input /ja "Light Arts" <me>')
			windower.chat.input:schedule(2.5,'/ja "Addendum: White" <me>')
			tickdelay = os.clock() + 1
			return true
		elseif not (buffactive['Addendum: White'] and abil_recasts[228] < latency) then
			windower.chat.input:schedule(1.5,'/ja "Addendum: White" <me>')
			tickdelay = os.clock() + 1
			return true
		end
	end
	
	return false
end

function check_flash_foil()
	if silent_check_silence() then return false end
	local spell_recasts = windower.ffxi.get_spell_recasts()
	
	if not buffactive['Enmity Boost'] and spell_recasts[476] < spell_latency then
		windower.chat.input('/ma "Crusade" <me>')
		tickdelay = os.clock() + 2
		return true
	elseif spell_recasts[112] < spell_latency then
		windower.chat.input('/ma "Flash" <t>')
		tickdelay = os.clock() + 2
		return true
	elseif spell_recasts[840] < spell_latency then
		windower.chat.input('/ma "Foil" <me>')
		tickdelay = os.clock() + 2
		return true
	else
		return false
	end
end

function update_melee_groups()
	if player.equipment.main then
		classes.CustomMeleeGroups:clear()
		
		if player.equipment.main == "Epeolatry" and state.Buff['Aftermath: Lv.3'] then
				classes.CustomMeleeGroups:append('AM')
		end
	end	
end

function check_hasso()
    if player.sub_job == 'SAM' and player.status == 'Engaged' and not (state.Stance.value == 'None' or state.Buff.Hasso or state.Buff.Seigan or state.Buff['SJ Restriction'] or main_weapon_is_one_handed() or silent_check_amnesia()) then
		
		local abil_recasts = windower.ffxi.get_ability_recasts()
		
		if state.Stance.value == 'Hasso' and abil_recasts[138] < latency then
			windower.chat.input('/ja "Hasso" <me>')
			tickdelay = os.clock() + 1.1
			return true
		elseif state.Stance.value == 'Seigan' and abil_recasts[139] < latency then
			windower.chat.input('/ja "Seigan" <me>')
			tickdelay = os.clock() + 1.1
			return true
		end
	
	end
		
	return false
end

function handle_elemental(cmdParams)
    -- cmdParams[1] == 'elemental'
    -- cmdParams[2] == ability to use

    if not cmdParams[2] then
        add_to_chat(123,'Error: No elemental command given.')
        return
    end
    local command = cmdParams[2]:lower()

	if command == 'spikes' then
		windower.chat.input('/ma "'..data.elements.spikes_of[state.ElementalMode.value]..' Spikes" <me>')
		return
	elseif command == 'enspell' then
		windower.chat.input('/ma "En'..data.elements.enspell_of[state.ElementalMode.value]..'" <me>')
		return
	elseif command == 'barelement' then
		windower.chat.input('/ma "'..data.elements.BarElement_of[state.ElementalMode.value]..'" <me>')
		return
	--Leave out target, let shortcuts auto-determine it.
	elseif command == 'weather' then
		if player.sub_job == 'RDM' then
			windower.chat.input('/ma "Phalanx" <me>')
		else
			local spell_recasts = windower.ffxi.get_spell_recasts()
				windower.chat.input('/ma "'..data.elements.storm_of[state.ElementalMode.value]..'"')
		end
		return
	end

	local target = '<t>'
	if cmdParams[3] then
		if tonumber(cmdParams[3]) then
			target = tonumber(cmdParams[3])
		else
			target = table.concat(cmdParams, ' ', 3)
			target = get_closest_mob_id_by_name(target) or '<t>'
		end
	end

	if command == 'nuke' or command == 'smallnuke' then
		local spell_recasts = windower.ffxi.get_spell_recasts()
	
		if command == 'nuke' and state.ElementalMode.value == 'Light' then
			local tiers = {'Holy II','Holy','Banish III','Banish II','Banish'}
			for k in ipairs(tiers) do
				if spell_recasts[get_spell_table_by_name(tiers[k]).id] < spell_latency and actual_cost(get_spell_table_by_name(tiers[k])) < player.mp then
					windower.chat.input('/ma "'..tiers[k]..'" '..target..'')
					return
				end
			end
		else
			local tiers = {' II',''}
			for k in ipairs(tiers) do
				if spell_recasts[get_spell_table_by_name(data.elements.nuke_of[state.ElementalMode.value]..''..tiers[k]..'').id] < spell_latency and actual_cost(get_spell_table_by_name(data.elements.nuke_of[state.ElementalMode.value]..''..tiers[k]..'')) < player.mp then
					windower.chat.input('/ma "'..data.elements.nuke_of[state.ElementalMode.value]..''..tiers[k]..'" '..target..'')
					return
				end
			end
		end
		add_to_chat(123,'Abort: All '..data.elements.nuke_of[state.ElementalMode.value]..' nukes on cooldown or or not enough MP.')
		
	elseif command:contains('tier') then
		local spell_recasts = windower.ffxi.get_spell_recasts()
		local tierlist = {['tier1']='',['tier2']=' II',['tier3']=' III',['tier4']=' IV',['tier5']=' V',['tier6']=' VI'}
		
		windower.chat.input('/ma "'..data.elements.nuke_of[state.ElementalMode.value]..tierlist[command]..'" '..target..'')
		
	elseif command == 'ara' then
		windower.chat.input('/ma "'..data.elements.nukera_of[state.ElementalMode.value]..'ra" '..target..'')
		
	elseif command == 'aga' then
		windower.chat.input('/ma "'..data.elements.nukega_of[state.ElementalMode.value]..'ga" '..target..'')
		
	elseif command == 'helix' then
		windower.chat.input('/ma "'..data.elements.helix_of[state.ElementalMode.value]..'helix" '..target..'')
	
	elseif command == 'enfeeble' then
		windower.chat.input('/ma "'..data.elements.elemental_enfeeble_of[state.ElementalMode.value]..'" '..target..'')
	
	elseif command == 'bardsong' then
		windower.chat.input('/ma "'..data.elements.threnody_of[state.ElementalMode.value]..' Threnody" '..target..'')

    else
        add_to_chat(123,'Unrecognized elemental command.')
    end
end

function check_buff()
	if state.AutoBuffMode.value ~= 'Off' and not data.areas.cities:contains(world.area) then
		local spell_recasts = windower.ffxi.get_spell_recasts()
		for i in pairs(buff_spell_lists[state.AutoBuffMode.Value]) do
			if not buffactive[buff_spell_lists[state.AutoBuffMode.Value][i].Buff] and (buff_spell_lists[state.AutoBuffMode.Value][i].When == 'Always' or (buff_spell_lists[state.AutoBuffMode.Value][i].When == 'Combat' and (player.in_combat or being_attacked)) or (buff_spell_lists[state.AutoBuffMode.Value][i].When == 'Engaged' and player.status == 'Engaged') or (buff_spell_lists[state.AutoBuffMode.Value][i].When == 'Idle' and player.status == 'Idle') or (buff_spell_lists[state.AutoBuffMode.Value][i].When == 'OutOfCombat' and not (player.in_combat or being_attacked))) and spell_recasts[buff_spell_lists[state.AutoBuffMode.Value][i].SpellID] < spell_latency and silent_can_use(buff_spell_lists[state.AutoBuffMode.Value][i].SpellID) then
				windower.chat.input('/ma "'..buff_spell_lists[state.AutoBuffMode.Value][i].Name..'" <me>')
				tickdelay = os.clock() + 2
				return true
			end
		end

		if not buffactive[data.elements.BarElement_of[state.ElementalMode.value]] then
			windower.chat.input('/ma "'..data.elements.BarElement_of[state.ElementalMode.value]..'" <me>')
			tickdelay = os.clock() + 1.1
			return true
		else
			return false
		end
		if state.AutoBuffMode.value == 'Melee' and player.in_combat then
			local abil_recasts = windower.ffxi.get_ability_recasts()
			
			if not buffactive['Swordplay'] and abil_recasts[24] < latency then
				windower.chat.input('/ja "Swordplay" <me>')
				tickdelay = os.clock() + 1.1
				return true
			elseif state.Buff['SJ Restriction'] then
				return false
			elseif player.sub_job == 'DRK' and not buffactive['Last Resort'] and abil_recasts[87] < latency then
				windower.chat.input('/ja "Last Resort" <me>')
				tickdelay = os.clock() + 1.1
				return true
			elseif player.sub_job == 'WAR' and not buffactive.Berserk and abil_recasts[1] < latency then
				windower.chat.input('/ja "Berserk" <me>')
				tickdelay = os.clock() + 1.1
				return true
			elseif player.sub_job == 'WAR' and not buffactive.Aggressor and abil_recasts[4] < latency then
				windower.chat.input('/ja "Aggressor" <me>')
				tickdelay = os.clock() + 1.1
				return true
			elseif player.sub_job == 'WAR' and not buffactive.Warcry and abil_recasts[2] < latency then
				windower.chat.input('/ja "Warcry" <me>')
				tickdelay = os.clock() + 1.1
				return true
			else
				return false
			end
		
		
	    elseif state.AutoBuffMode.value ~= 'Melee' and (player.in_combat or being_attacked) then
			local abil_recasts = windower.ffxi.get_ability_recasts()

			if not buffactive['Swordplay'] and abil_recasts[24] < latency then
				windower.chat.input('/ja "Swordplay" <me>')
				tickdelay = os.clock() + 1.1
				return true
			elseif state.Buff['SJ Restriction'] then
				return false
			elseif player.sub_job == 'WAR' and not buffactive.Berserk and abil_recasts[3] < latency then
				windower.chat.input('/ja "Defender" <me>')
				tickdelay = os.clock() + 1.1
				return true
			elseif player.sub_job == 'WAR' and not buffactive.Warcry and abil_recasts[2] < latency then
				windower.chat.input('/ja "Warcry" <me>')
				tickdelay = os.clock() + 1.1
				return true
			elseif state.AutoRuneMode.Value == false then
				windower.chat.input('gs c set AutoRuneMode true')
				return true

			--[[elseif state.AutoRuneMode.Value == false then
				windower.chat.input('gs c elemental barelement')
				return true
            ]]
			else

				return false
			
			end
		end
	end		

	return false
end

function check_buffup()
	if buffup ~= '' then
		local needsbuff = false
		for i in pairs(buff_spell_lists[buffup]) do
			if not buffactive[buff_spell_lists[buffup][i].Buff] and silent_can_use(buff_spell_lists[buffup][i].SpellID) then
				needsbuff = true
				break
			end
		end
	
		if not needsbuff then
			add_to_chat(217, 'All '..buffup..' buffs are up!')
			buffup = ''
			return false
		end
		
		local spell_recasts = windower.ffxi.get_spell_recasts()
		
		for i in pairs(buff_spell_lists[buffup]) do
			if not buffactive[buff_spell_lists[buffup][i].Buff] and silent_can_use(buff_spell_lists[buffup][i].SpellID) and spell_recasts[buff_spell_lists[buffup][i].SpellID] < spell_latency then
				windower.chat.input('/ma "'..buff_spell_lists[buffup][i].Name..'" <me>')
				tickdelay = os.clock() + 2
				return true
			end
		end
		
		return false
	else
		return false
	end
end

function user_job_target_change(target)  
	
	local target = windower.ffxi.get_mob_by_target('t')
	local sub= windower.ffxi.get_mob_by_target('st')
	if (target ~= nil) and (sub == nil) then
		if target.name == "Ironshell" or target.name == "Ghast" then
			--windower.chat.input('gs c set RuneElement Ignis;gs c set ElementalMode Fire;gs c set AutoBuffMode Sortie;gs c set AutoDefenseMode true;gs c set AutoTankMode true;gs c set DefenseMode Magical;gs c set AutoRuneMode true') 			
			windower.send_command('input /p >>> '..auto_translate('Rayke')..''..auto_translate(''..target.name..'')..'['..target.name..'] Wind hand: 70% Ice, Thunder hand: 70% EarthWind and Thunder hands:  only Ice damage will be effective.')  -- code add by (Aragan@Asura)
			windower.send_command('input /echo ['..target.name..'] Wind hand: 70% Ice, Thunder hand: 70% EarthWind and Thunder hands:  only Ice damage will be effective.')  -- code add by (Aragan@Asura)

		elseif target.name == "Aminon" then
			windower.chat.input('gs c set RuneElement Lux;gs c set ElementalMode Light;gs c set AutoBuffMode Aminon;gs c set AutoDefenseMode true;gs c set AutoTankMode true;gs c set DefenseMode Magical;gs c set AutoRuneMode true') 			
        elseif target.name == "Ghatjot" or target.name == "Dhartok" then
			windower.chat.input('gs c set RuneElement Tellus;gs c set ElementalMode Earth;gs c set AutoBuffMode Sortie;gs c set AutoDefenseMode true;gs c set AutoTankMode true;gs c set DefenseMode Magical;gs c set AutoRuneMode true') 			
		elseif target.name == "Skomora" or target.name == "Triboulex" then
			windower.chat.input('gs c set RuneElement Ignis;gs c set ElementalMode Fire;gs c set AutoBuffMode Sortie;gs c set AutoDefenseMode true;gs c set AutoTankMode true;gs c set DefenseMode Magical;gs c set AutoRuneMode true') 			
		end
	end
end

windower.register_event('incoming text',function(org)     

	--[[
tel what proc need
The fiend appears vulnerable to ice elemental magic!
proc done
attack staggers the fiend!
]]

	if string.find(org, "Aita readies Vivisection") then
		windower.chat.input('/ja "Elemental Sforzo" <me>')
		state.MagicalDefenseMode:set('MDT')
		windower.send_command('input /p Aita uses Vivisection <call14>!')  -- code add by (Aragan@Asura)
		windower.chat.input('/ja "Liement" <me>')
	end
	if string.find(org, "Degei readies Vivisection") then
		windower.chat.input('/ja "Elemental Sforzo" <me>')
		state.MagicalDefenseMode:set('MDT')
		windower.send_command('input /p Degei uses Vivisection <call14>!')  -- code add by (Aragan@Asura)
		windower.chat.input('/ja "Liement" <me>')
	end
	if string.find(org, "Triboulex readies Setting the Stage") then
		windower.chat.input('/ja "Elemental Sforzo" <me>')
		state.MagicalDefenseMode:set('MDT')
		windower.send_command('input /p Triboulex uses Setting the Stage <call14>!')  -- code add by (Aragan@Asura)
		windower.chat.input('/ja "Liement" <me>')
	end
	if string.find(org, "Skomora readies Setting the Stage") then
		windower.chat.input('/ja "Elemental Sforzo" <me>')
		state.MagicalDefenseMode:set('MDT')
		windower.send_command('input /p Skomora uses Setting the Stage <call14>!')  -- code add by (Aragan@Asura)
		windower.chat.input('/ja "Liement" <me>')
	end
	if string.find(org, "Chokehold") then
		windower.chat.input('gs c set ElementalMode Ice')

			--windower.send_command('input //gs c set ElementalMode Ice')
			--windower.send_command('input /ma Blizzard <bt>')
			--windower.send_command('input /p Chokehold >> ITS WEAK ICE PROC <call14>!')  -- code add by (Aragan@Asura)
			--windower.chat.input('input /p Chokehold >> ITS WEAK ICE PROC <call14>!')
	end
	--[[if string.find(org, "Leshonn uses Tearing Gust ") then
		windower.chat.input('/ja "Elemental Sforzo" <me>')
		windower.send_command('input /p Leshonn uses Tearing Gust  <call14>!')  -- code add by (Aragan@Asura)
		windower.chat.input('/ja "Liement" <me>')
	end
	if string.find(org, "Gartell uses Tearing Gust ") then
		windower.chat.input('/ja "Elemental Sforzo" <me>')
		windower.send_command('input /p Gartell uses Tearing Gust  <call14>!')  -- code add by (Aragan@Asura)
		windower.chat.input('/ja "Liement" <me>')
	end]]
		--Sortie 	--Vagary

	
	if (player.sub_job == 'SCH' or player.sub_job == 'RDM') and not state.Buff['SJ Restriction'] then
		if string.find(org, "Flaming Kick") or string.find(org, "Demonfire") then
			windower.send_command('input //gs c set ElementalMode water')
			windower.send_command('input /ma water <bt>')
			windower.send_command('input /p Flaming Kick >> ITS WEAK WATER PROC <call14>!')  -- code add by (Aragan@Asura)
			tickdelay = os.clock() + 1.1
			return true
	
	
		end
		if string.find(org, "Flashflood") or string.find(org, "Torrential Pain") then
			windower.send_command('input //gs c set ElementalMode Lightning')
			windower.send_command('input /ma thunder <bt>')
			windower.send_command('input /p Flashflood >> ITS WEAK THUNDER PROC <call14>!')  -- code add by (Aragan@Asura)
			tickdelay = os.clock() + 1.1
			return true
	
		end
		if string.find(org, "Icy Grasp") or string.find(org, "Frozen Blood") then
			windower.send_command('input //gs c set ElementalMode Fire')
			windower.send_command('input /ma fire <bt>')
			windower.send_command('input /p Flashflood >> ITS WEAK FIRE PROC <call14>!')  -- code add by (Aragan@Asura)
			tickdelay = os.clock() + 1.1
			return true
	
		end
		if string.find(org, "Eroding Flesh") or string.find(org, "Ensepulcher") then
			windower.send_command('input //gs c set ElementalMode Wind')
			windower.send_command('input /ma wind <bt>')
			windower.send_command('input /p Flashflood >> ITS WEAK WIND PROC <call14>!')  -- code add by (Aragan@Asura)
			tickdelay = os.clock() + 1.1
			return true
	
		end
		if string.find(org, "Fulminous Smash") or string.find(org, "Ceaseless Surge") then
			windower.send_command('input //gs c set ElementalMode Earth')
			windower.send_command('input /ma Stone <bt>')
			windower.send_command('input /p Flashflood >> ITS WEAK STONE PROC <call14>!')  -- code add by (Aragan@Asura)
			tickdelay = os.clock() + 1.1
			return true
	
		end
		if string.find(org, "Blast of Reticence") then
			windower.send_command('input //gs c set ElementalMode Ice')
			windower.send_command('input /ma Blizzard <bt>')
			windower.send_command('input /p Flashflood >> ITS WEAK ICE PROC <call14>!')  -- code add by (Aragan@Asura)
			tickdelay = os.clock() + 1.1
			return true
	
		end
	end
end)