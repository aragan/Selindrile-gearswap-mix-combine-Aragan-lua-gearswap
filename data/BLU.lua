--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
-- __________.__                                ________                          __               .__.__  __      __  .__    .__           _____.__.__              
-- \______   |  |   ____ _____    ______ ____   \______ \   ____     ____   _____/  |_    ____   __| _|___/  |_  _/  |_|  |__ |__| ______ _/ ____|__|  |   ____      
--  |     ___|  | _/ __ \\__  \  /  ____/ __ \   |    |  \ /  _ \   /    \ /  _ \   __\ _/ __ \ / __ ||  \   __\ \   __|  |  \|  |/  ___/ \   __\|  |  | _/ __ \     
--  |    |   |  |_\  ___/ / __ \_\___ \\  ___/   |    `   (  <_> ) |   |  (  <_> |  |   \  ___// /_/ ||  ||  |    |  | |   Y  |  |\___ \   |  |  |  |  |_\  ___/     
--  |____|   |____/\___  (____  /____  >\___  > /_______  /\____/  |___|  /\____/|__|    \___  \____ ||__||__|    |__| |___|  |__/____  >  |__|  |__|____/\___  > /\ 
--                     \/     \/     \/     \/          \/              \/                   \/     \/                      \/        \/                      \/  \/ 
--
--	Please do not edit this file!							Please do not edit this file!							Please do not edit this file!
--
--	Editing this file will cause you to be unable to use Github Desktop to update!
--
--	Any changes you wish to make in this file you should be able to make by overloading. That is Re-Defining the same variables or functions in another file, by copying and
--	pasting them to a file that is loaded after the original file, all of my library files, and then job files are loaded first.
--	The last files to load are the ones unique to you. User-Globals, Charactername-Globals, Charactername_Job_Gear, in that order, so these changes will take precedence.
--
--	You may wish to "hook" into existing functions, to add functionality without losing access to updates or fixes I make, for example, instead of copying and editing
--	status_change(), you can instead use the function user_status_change() in the same manner, which is called by status_change() if it exists, most of the important 
--  gearswap functions work like this in my files, and if it's unique to a specific job, user_job_status_change() would be appropriate instead.
--
--  Variables and tables can be easily redefined just by defining them in one of the later loaded files: autofood = 'Miso Ramen' for example.
--  States can be redefined as well: state.HybridMode:options('Normal','PDT') though most of these are already redefined in the gear files for editing there.
--	Commands can be added easily with: user_self_command(commandArgs, eventArgs) or user_job_self_command(commandArgs, eventArgs)
--
--	If you're not sure where is appropriate to copy and paste variables, tables and functions to make changes or add them:
--		User-Globals.lua - 			This file loads with all characters, all jobs, so it's ideal for settings and rules you want to be the same no matter what.
--		Charactername-Globals.lua -	This file loads with one character, all jobs, so it's ideal for gear settings that are usable on all jobs, but unique to this character.
--		Charactername_Job_Gear.lua-	This file loads only on one character, one job, so it's ideal for things that are specific only to that job and character.
--
--
--	If you still need help, feel free to contact me on discord or ask in my chat for help: https://discord.gg/ug6xtvQ
--  !Please do NOT message me in game about anything third party related, though you're welcome to message me there and ask me to talk on another medium.
--
--  Please do not edit this file!							Please do not edit this file!							Please do not edit this file!
-- __________.__                                ________                          __               .__.__  __      __  .__    .__           _____.__.__              
-- \______   |  |   ____ _____    ______ ____   \______ \   ____     ____   _____/  |_    ____   __| _|___/  |_  _/  |_|  |__ |__| ______ _/ ____|__|  |   ____      
--  |     ___|  | _/ __ \\__  \  /  ____/ __ \   |    |  \ /  _ \   /    \ /  _ \   __\ _/ __ \ / __ ||  \   __\ \   __|  |  \|  |/  ___/ \   __\|  |  | _/ __ \     
--  |    |   |  |_\  ___/ / __ \_\___ \\  ___/   |    `   (  <_> ) |   |  (  <_> |  |   \  ___// /_/ ||  ||  |    |  | |   Y  |  |\___ \   |  |  |  |  |_\  ___/     
--  |____|   |____/\___  (____  /____  >\___  > /_______  /\____/  |___|  /\____/|__|    \___  \____ ||__||__|    |__| |___|  |__/____  >  |__|  |__|____/\___  > /\ 
--                     \/     \/     \/     \/          \/              \/                   \/     \/                      \/        \/                      \/  \/ 
--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
-------------------------------------------------------------------------------------------------------------------
-- Setup functions for this job.  Generally should not be modified.
-------------------------------------------------------------------------------------------------------------------

-- Initialization function for this job file.
function get_sets()
    -- Load and initialize the include file.
    include('Sel-Include.lua')
	
	organizer_items = {
		"Airmid's Gorget",
		"Tumult's Blood",
		"Sarama's Hide",
		"Hidhaegg's Scale",
		"Sovereign's Hide",
		"Grape Daifuku",
		"Soy Ramen",
		"G. Curry Bun +1",
		"Pukatrice Egg",
		"Moogle Amp.",
		"Popo. con Queso",
		"Pear Crepe",
		"Om. Sandwich",
		"Red Curry Bun",
		"Gyudon",
		"Reraiser",
		"Hi-Reraiser",
		"Vile Elixir",
		"Vile Elixir +1",
		"Miso Ramen",
		"Carbonara",
		"Silent Oil",
		"Salt Ramen",
		"Panacea",
		"Sublime Sushi",
		"Sublime Sushi 1+",
		"Prism Powder",
		"Antacid",
		"Icarus Wing",
		"Warp Cudgel",
		"Holy Water",
		"Sanjaku-Tenugui",
		"Shinobi-Tabi",
		"Shihei",
		"Remedy",
		"Emporox's Ring",
		"Red Curry Bun",
		"Instant Reraise",
		"Black Curry Bun",
		"Rolan. Daifuku",}
end


-- Setup vars that are user-independent.  state.Buff vars initialized here will automatically be tracked.
function job_setup()

    state.Buff['Burst Affinity'] = buffactive['Burst Affinity'] or false
    state.Buff['Chain Affinity'] = buffactive['Chain Affinity'] or false
	state.Buff['Azure Lore'] = buffactive['Azure Lore'] or false
    state.Buff.Convergence = buffactive.Convergence or false
    state.Buff.Diffusion = buffactive.Diffusion or false
    state.Buff.Efflux = buffactive.Efflux or false
    state.Buff['Aftermath: Lv.3'] = buffactive['Aftermath: Lv.3'] or false
    state.Buff['Unbridled Learning'] = buffactive['Unbridled Learning'] or false
	state.Buff['Unbridled Wisdom'] = buffactive['Unbridled Wisdom'] or false
	state.AutoEquipBurst = M(true)
    state.MagicBurst = M(false, 'Magic Burst')
    state.HippoMode = M(false, "hippoMode")
	state.AutoCureMode = M(true, 'Auto Cure Mode')
	state.SelectNPCTargets    = M(false, 'Select NPC Targets')
	state.PCTargetMode        = M{['description'] = 'PC Target Mode', 'default', 'stpt', 'stal', 'stpc'}
	state.AutoBLUSpam = M(false, 'AutoBLUSpam')

	state.LearningMode = M(false, 'Learning Mode')
	state.AutoUnbridled = M(true, 'Auto Unbridled Mode')
	autows = 'Chant Du Cygne'
	autofood = 'Soy Ramen'
	
    blue_magic_maps = {}
    
    -- Mappings for gear sets to use for various blue magic spells.
    -- While Str isn't listed for each, it's generally assumed as being at least
    -- moderately signficant, even for spells with other mods, if only for pDif.
    
    -- Physical Spells --
    
    -- Physical spells with no particular (or known) stat mods
    blue_magic_maps.Physical = S{
        'Bilgestorm'
    }

    -- Spells with heavy accuracy penalties, that need to prioritize accuracy.
    blue_magic_maps.PhysicalAcc = S{
        'Heavy Strike',
    }

    -- Physical spells with Str stat mod
    blue_magic_maps.PhysicalStr = S{
        'Bloodrake','Death Scissors','Dimensional Death',
        'Empty Thrash','Quadrastrike','Sinker Drill','Spinal Cleave',
        'Uppercut','Vertical Cleave',
    }
        
    -- Physical spells with Dex stat mod
    blue_magic_maps.PhysicalDex = S{
        'Amorphic Spikes','Asuran Claws','Claw Cyclone','Disseverment',
        'Foot Kick','Frenetic Rip','Goblin Rush','Hysteric Barrage','Paralyzing Triad',
        'Sickle Slash','Smite of Rage','Thrashing Assault','Vanity Dive',
    }
        
    -- Physical spells with Vit stat mod
    blue_magic_maps.PhysicalVit = S{
        'Body Slam','Cannonball','Delta Thrust','Glutinous Dart','Grand Slam',
        'Power Attack','Quad. Continuum',
    }
        
    -- Physical spells with Agi stat mod
    blue_magic_maps.PhysicalAgi = S{
        'Helldive','Jet Stream',
    }

    -- Physical spells with Int stat mod
    blue_magic_maps.PhysicalInt = S{
        'Mandibular Bite',
    }

    -- Physical spells with Mnd stat mod
    blue_magic_maps.PhysicalMnd = S{
        'Ram Charge','Screwdriver','Tourbillion'
    }

    -- Physical spells with Chr stat mod
    blue_magic_maps.PhysicalChr = S{
        'Bludgeon'
    }

    -- Physical spells with HP stat mod
    blue_magic_maps.PhysicalHP = S{
        'Final Sting'
    }

    -- Magical Spells --

    -- Magical spells with the typical Int mod
    blue_magic_maps.Magical = S{
        'Blastbomb','Blazing Bound','Bomb Toss','Cursed Sphere','Dark Orb','Death Ray',
        'Diffusion Ray','Droning Whirlwind','Embalming Earth','Firespit','Foul Waters',
        'Ice Break','Leafstorm','Maelstrom','Rail Cannon','Regurgitation','Rending Deluge',
        'Retinal Glare','Subduction','Tearing Gust','Tem. Upheaval','Water Bomb','Molting Plumage',
		'Nectarous Deluge','Searing Tempest','Blinding Fulgor','Spectral Floe','Scouring Spate',
		'Anvil Lightning','Silent Storm','Entomb','Tenebral Crush','Palling Salvo'
    }

    -- Magical spells with a primary Mnd mod 
    blue_magic_maps.MagicalMnd = S{
        'Acrid Stream','Evryone. Grudge','Magic Hammer','Mind Blast'
    }

    -- Magical spells with a primary Chr mod
    blue_magic_maps.MagicalChr = S{
        'Eyes On Me','Mysterious Light'
    }

    -- Magical spells with a Vit stat mod
    blue_magic_maps.MagicalVit = S{
        'Thermal Pulse'
    }

    -- Magical spells with a Dex stat mod (on top of Int)
    blue_magic_maps.MagicalDex = S{
        'Charged Whisker','Gates of Hades'
    }

    -- Magical spells with an Agi stat mod
    blue_magic_maps.MagicalAgi = S{
        'Crashing Thunder'
    }

    -- Magical spells (generally debuffs) that we want to focus on magic accuracy over damage.
    -- Add Int for damage where available, though.
    blue_magic_maps.MagicAccuracy = S{
        '1000 Needles','Absolute Terror','Actinic Burst','Auroral Drape','Awful Eye',
        'Bad Breath', 'Blank Gaze','Blistering Roar','Blitzstrahl','Blood Drain','Blood Saber','Cesspool','Chaotic Eye',
        'Cimicine Discharge','Cold Wave','Corrosive Ooze','Cruel Joke','Demoralizing Roar','Digest',
        'Dream Flower','Enervation','Feather Tickle','Filamented Hold','Frightful Roar',
        'Frost Breath','Geist Wall','Hecatomb Wave','Infrasonics','Jettatura','Light of Penance',
        'Lowing','Mind Blast','Mortal Ray','MP Drainkiss','Osmosis','Radiant Breath','Reaving Wind',
        'Sandspin','Sandspray','Sheep Song','Soporific','Sound Blast','Stinking Gas',
        'Sub-zero Smash','Temporal Shift','Thunderbolt','Venom Shell','Voracious Trunk',
		'Yawn', 'Atra. Libations'
    }
        
    -- Breath-based spells that we don't care about the added effect of.
    blue_magic_maps.Breath = S{
        'Flying Hip Press','Heat Breath',
        'Hecatomb Wave','Magnetite Cloud','Poison Breath','Self-Destruct',
        'Thunder Breath','Vapor Spray','Wind Breath'
    }

    -- Physical stun spells and physical added effect spells.
    blue_magic_maps.Stun = S{
        'Barbed Crescent','Battle Dance','Benthic Typhoon','Bilgestorm',
		'Feather Storm','Frypan','Head Butt','Hydro Shot','Pinecone Bomb','Queasyshroom',
		'Saurian Slide','Seedspray','Spiral Spin','Sprout Smack','Sub-zero Smash',
		'Sudden Lunge','Sweeping Gouge','Tail Slap','Terror Touch','Wild Oats','Whirl of Rage',
    }
        
    -- Healing spells
    blue_magic_maps.Healing = S{
        'Exuviation','Healing Breeze','Magic Fruit','Plenilune Embrace',
		'Pollen','Restoral','White Wind','Wild Carrot'
    }
    
    -- Buffs that depend on blue magic skill that don't cap very low.
    blue_magic_maps.SkillBasedBuff = S{
        'Diamondhide','Magic Barrier','Occultation','Plasma Charge','Reactor Cool',
    }

    -- Other general buffs
    blue_magic_maps.Buff = S{
        'Amplification','Animating Wail','Barrier Tusk','Battery Charge','Carcharian Verve','Cocoon',
        'Erratic Flutter','Fantod','Feather Barrier','Harden Shell','Memento Mori','Metallic Body',
		'Mighty Guard','Nat. Meditation','Orcish Counterstance','Pyric Bulwark',
		'Refueling','Regeneration','Saline Coat','Triumphant Roar','Warm-Up','Winds of Promy.',
        'Zephyr Mantle'
    }
    
    aoe_blue_magic_healing = S{
        'Healing Breeze','White Wind'
    }
    
    -- Spells that require Unbridled Learning to cast.
    unbridled_spells = S{
        'Absolute Terror','Blistering Roar','Bloodrake','Carcharian Verve','Cesspool',
        'Crashing Thunder','Cruel Joke','Droning Whirlwind','Gates of Hades','Harden Shell','Mighty Guard','Polar Roar',
        'Pyric Bulwark','Tearing Gust','Thunderbolt','Tourbillion','Uproot'
    }

	state.Spellset = M{['description']='Spellset','vagary', 'aoe', 'aoe2','all', 'mix', 'mix2',
	'magic','blu', 'sortie', 'farm','dd','ddapex', 'magic', 'vw1', 'mboze','ody', 'unm',
	 'ody2','sortie1','evasion','sortie2','hp','def','def2','dhartok','hp','1','2'}

	 Haste = 0
	 DW_needed = 0
	 DW = false
	 determine_haste_group()
	 update_combat_form()  
	init_job_states({"Capacity","AutoRuneMode","AutoTrustMode","AutoWSMode","AutoShadowMode","AutoFoodMode","AutoNukeMode","AutoStunMode","AutoDefenseMode","HippoMode","AutoMedicineMode"},{"AutoBuffMode","AutoSambaMode","Weapons","OffenseMode","WeaponskillMode","IdleMode","Passive","CastingMode","RuneElement","ElementalMode","LearningMode","TreasureMode"})
end

-------------------------------------------------------------------------------------------------------------------
-- Job-specific hooks for standard casting events.
-------------------------------------------------------------------------------------------------------------------
-- Set eventArgs.handled to true if we don't want any automatic gear equipping to be done.
-- Set eventArgs.useMidcastGear to true if we want midcast gear equipped on precast.

function job_filtered_action(spell, eventArgs)
	if spell.type == 'WeaponSkill' then
		local available_ws = S(windower.ffxi.get_abilities().weapon_skills)
		-- WS 160 is Shining Strike, meaning a club is equipped.
		if available_ws:contains(160) then
            if spell.english == "Chant du Cygne" then
                send_command('@input /ws "Realmrazer" '..spell.target.raw)
                cancel_spell()
				eventArgs.cancel = true
            elseif spell.english == "Sanguine Blade" then
                send_command('@input /ws "Flash Nova" '..spell.target.raw)
                cancel_spell()
				eventArgs.cancel = true
            elseif spell.english == "Flat Blade" then
                send_command('@input /ws "Brainshaker" '..spell.target.raw)
                cancel_spell()
				eventArgs.cancel = true
            elseif spell.english == "Expiacion" then
                send_command('@input /ws "Judgment" '..spell.target.raw)
                cancel_spell()
				eventArgs.cancel = true
            elseif spell.english == "Vorpal Blade" then
                send_command('@input /ws "True Strike" '..spell.target.raw)
                cancel_spell()
				eventArgs.cancel = true
            elseif spell.english == "Savage Blade" then
                send_command('@input /ws "Black Halo" '..spell.target.raw)
                cancel_spell()
				eventArgs.cancel = true
            end
        end
	end

end
function job_filter_pretarget(spell, spellMap, eventArgs)
	if (spell.skill == 'Blue Magic' and spellMap:contains('Magical')) then


        local allRecasts = windower.ffxi.get_ability_recasts()
        local Burst_AffinityCooldown = allRecasts[182]
        
        
        if player.main_job_level >= 25 and Burst_AffinityCooldown < 3 then
            cast_delay(1.1)
            send_command('@input /ja "Burst Affinity" <me>')
        end
        if not midaction() then
            job_update()
        end
	end
	if (spell.skill == 'Blue Magic' and spellMap:contains('Physical')) then


		local allRecasts = windower.ffxi.get_ability_recasts()
		local Chain_AffinityCooldown = allRecasts[181]
		
		
		if player.main_job_level >= 40 and Chain_AffinityCooldown < 3 then
			cast_delay(1.1)
			send_command('@input /ja "Chain Affinity" <me>')
		end
		if not midaction() then
			job_update()
		end
	end
	local abil_recasts = windower.ffxi.get_ability_recasts()

	if spell.skill == 'Blue Magic' and (unbridled_spells:contains(spell.english) and blue_magic_maps.Buff:contains(spell.english)) and not buffactive.Diffusion and abil_recasts[184] < latency then
		cast_delay(1.1)
		windower.chat.input('/ja "Diffusion" <me>')
	end
	local abil_recasts = windower.ffxi.get_ability_recasts()

	if player.target.type == 'MONSTER' and spell.skill == 'Blue Magic' and unbridled_spells:contains(spell.english) and not (state.Buff['Unbridled Learning'] or state.Buff['Unbridled Wisdom']) and windower.ffxi.get_ability_recasts()[81] < latency then
		cast_delay(1.1)
		windower.chat.input('/ja "Unbridled Learning" <me>')
		if not midaction() then
			job_update()
		end
	end


	if party.count ~= 1 and spell.skill == 'Enhancing Magic' and (spell.english:contains('storm')) and get_current_stratagem_count() > 0 then
		cast_delay(1.1)
		windower.chat.input('/ja "Accession" <me>')
		add_to_chat(204, 'Stratagem Charges Available: ['..get_current_stratagem_count()..']~~~')
		send_command('@input /echo <recast=Stratagems>')
		send_command('@input /p <recast=Stratagems>')


	end
	
	if party.count ~= 1 and (spell.english == 'Sneak' or spell.english == 'Invisible') and get_current_stratagem_count() > 0 then
		cast_delay(1.1)
		windower.chat.input('/ja "Accession" <me>')
		add_to_chat(204, 'Stratagem Charges Available: ['..get_current_stratagem_count()..']~~~')
		send_command('@input /echo <recast=Stratagems>')
		send_command('@input /p <recast=Stratagems>')
		if not midaction() then
			job_update()
		end
	end
	auto_change_target(spell, spellMap)  

end
function job_pretarget(spell, spellMap, eventArgs)

end

function job_filter_precast(spell, spellMap, eventArgs)
	if spell.skill == 'Blue Magic' and unbridled_spells:contains(spell.english) and not (state.Buff['Unbridled Learning'] or state.Buff['Unbridled Wisdom']) then
		if (state.AutoUnbridled.value or buffup ~= '' or state.AutoBuffMode.value ~= 'Off') and (windower.ffxi.get_ability_recasts()[81] < latency and (windower.ffxi.get_spell_recasts()[spell.recast_id]/60) < spell_latency) then
			eventArgs.cancel = true
			windower.chat.input('/ja "Unbridled Learning" <me>')
			windower.chat.input:schedule(1,'/ma "'..spell.english..'" '..spell.target.raw..'')
			return
		else
			eventArgs.cancel = true
			add_to_chat(123,'Abort: Unbridled Learning not active.')
		end
	end
end
	
function job_precast(spell, spellMap, eventArgs)
	if spell.action_type == 'Magic' then
        if state.CastingMode.value == 'Proc' then
            classes.CustomClass = 'Proc'
		end
	end
end

function job_post_precast(spell, spellMap, eventArgs)

	if spell.type == 'WeaponSkill' then
		local WSset = standardize_set(get_precast_set(spell, spellMap))
		local wsacc = check_ws_acc()
		
		if (WSset.ear1 == "Moonshade Earring" or WSset.ear2 == "Moonshade Earring") then
			-- Replace Moonshade Earring if we're at cap TP
			if get_effective_player_tp(spell, WSset) > 3200 then
				if wsacc:contains('Acc') and not buffactive['Sneak Attack'] and sets.AccMaxTP then
					equip(sets.AccMaxTP[spell.english] or sets.AccMaxTP)
				elseif sets.MaxTP then
					equip(sets.MaxTP[spell.english] or sets.MaxTP)
				else
				end
			end
		end

	end

    -- If in learning mode, keep on gear intended to help with that, regardless of action.
	if state.LearningMode.value then
        equip(sets.Learning)
    end
end
function job_midcast(spell, action, spellMap, eventArgs)
	--Probably overkill but better safe than sorry.
	if spell.action_type == 'Ranged Attack' then
		disable('ammo')
		add_to_chat(123,"Locking Ammo slot for RA!")
		return
	end
end		
-- Run after the default midcast() is done.
-- eventArgs is the same one used in job_midcast, in case information needs to be persisted.
function job_post_midcast(spell, spellMap, eventArgs)
    -- Add enhancement gear for Chain Affinity, etc.
    if not eventArgs.handled and spell.skill == 'Blue Magic' then
        if spellMap == 'Healing' then
			if (state.Weapons.value == 'None' or state.UnlockWeapons.value) and sets.midcast['Blue Magic'].UnlockedHealing then
				equip(sets.midcast['Blue Magic'].UnlockedHealing)
			end
			
			if spell.target.type == 'SELF' then
				if aoe_blue_magic_healing:contains(spell.english) then
					if (state.Weapons.value == 'None' or state.UnlockWeapons.value) and sets.midcast['Blue Magic'].UnlockedAoEHealing then
						equip(sets.midcast['Blue Magic'].UnlockedAoEHealing)
					elseif sets.midcast['Blue Magic'].AoEHealing then
						equip(sets.midcast['Blue Magic'].AoEHealing)
					end
				elseif sets.Self_Healing then
					equip(sets.Self_Healing)
				end
			end
			
			if spell.element ~= 'None' and (spell.element == world.weather_element or spell.element == world.day_element) and item_available('Hachirin-no-Obi') then
				equip({waist="Hachirin-no-Obi"})
			end
				
		elseif spellMap:contains('Magical') then
			if state.MagicBurstMode.value ~= 'Off' and (state.Buff['Burst Affinity'] or state.Buff['Azure Lore']) then
				equip(sets.MagicBurst)
			end
			if spell.element == world.weather_element or spell.element == world.day_element then
				if state.CastingMode.value == 'Fodder' then
					-- if item_available('Twilight Cape') and not state.Capacity.value then
						-- sets.TwilightCape = {back="Twilight Cape"}
						-- equip(sets.TwilightCape)
					-- end
					if spell.element == world.day_element and not (world.day_element == 'Dark' or world.day_element == 'Light') then
						if item_available('Zodiac Ring') then
							sets.ZodiacRing = {ring2="Zodiac Ring"}
							equip(sets.ZodiacRing)
						end
					end
				end
			end
			
			if spell.element and sets.element[spell.element] then
				equip(sets.element[spell.element])
			end
			
			if state.TreasureMode.value == "Tag" then equip(sets.TreasureHunter) end

		end
		
        for buff,active in pairs(state.Buff) do
            if active and sets.buff[buff] then
                equip(sets.buff[buff])
            end
        end

    elseif spell.skill == 'Elemental Magic' and default_spell_map ~= 'ElementalEnfeeble' then
        if state.MagicBurstMode.value ~= 'Off' then equip(sets.MagicBurst) end
	
	end
	
    -- If in learning mode, keep on gear intended to help with that, regardless of action.
    if state.LearningMode.value == true then
		equip(sets.Learning)
    end
	if state.CastingMode.value == 'SIRD' then
		equip(sets.SIRD)
	elseif state.CastingMode.value == 'ConserveMP' then
		equip(sets.ConserveMP)
	else

	end
    if spell.skill == 'Enhancing Magic' or spell.skill == 'Blue Magic' and classes.NoSkillSpells:contains(spell.english) then
		if state.CastingMode.value == 'SIRD' then
			equip(sets.SIRD)
		elseif state.CastingMode.value == 'ConserveMP' then
			equip(sets.ConserveMP)
		else

		end
	end
	if spell.skill == 'Elemental Magic' or spell.skill == 'Blue Magic' and (state.MagicBurst.value or AEBurst) then
        equip(sets.magicburst)
        if spell.english == "Impact" then
            equip(sets.midcast.Impact)
        end
    end
end

function job_filter_aftercast(spell, spellMap, eventArgs)
	if (player.in_combat or being_attacked) and (spellMap == 'Cure' or blue_magic_maps.Healing:contains(spell.english) or spell.skill == 'Enhancing Magic') and spell.interrupted then
		state.CastingMode:set('SIRD')
		--send_command('gs c set state.CastingMode.value SIRD')
		send_command('gs c update')
		tickdelay = os.clock() + 1.1
	elseif not data.areas.cities:contains(world.area) and not (player.in_combat or being_attacked) then
		state.CastingMode:set('Duration')
		send_command('gs c update')
		tickdelay = os.clock() + 1.1
    end
	if not spell.interrupted then
        if spell.english == "Dream Flower" then
            send_command('@timers c "Dream Flower ['..spell.target.name..']" 90 down spells/00098.png')
			send_command('@input /p "Dream Flower Sleep ['..spell.target.name..']" 90 sec')

		elseif spell.english == "Soporific" then
            send_command('@timers c "Sleep ['..spell.target.name..']" 90 down spells/00259.png')
			send_command('@input /p "Soporific Sleep ['..spell.target.name..']" 90 sec')

		elseif spell.english == "Sheep Song" then
            send_command('@timers c "Sheep Song ['..spell.target.name..']" 60 down spells/00098.png')
			send_command('@input /p "Sheep Song Sleep ['..spell.target.name..']" 60 sec')

		elseif spell.english == "Yawn" then
            send_command('@timers c "Yawn ['..spell.target.name..']" 60 down spells/00098.png')
			send_command('@input /p "Yawn Sleep ['..spell.target.name..']" 60 sec')

		elseif spell.english == "Entomb" then
            send_command('@timers c "Entomb ['..spell.target.name..']" 60 down spells/00547.png')
			send_command('@input /p "Entomb Petrify ['..spell.target.name..']" 60 sec')

		elseif spell.english == "Tenebral Crush" then
            send_command('@timers c "Tenebral Crush ['..spell.target.name..']" 90 down spells/00259.png')
			send_command('@input /p "Tenebral Crush Def. Down -20%. on ['..spell.target.name..']" 90 sec')

		end
    end
	if spell.action_type == 'Ranged Attack' then
		enable('ammo')
		add_to_chat(123,"Re-enabling Ammo slot after RA!")
		return
	end	
end
function job_aftercast(spell, spellMap, eventArgs)

	if state.MagicBurstMode.value == 'Single' then
		if spell.skill == 'Elemental Magic' or (spell.skill == 'Blue Magic' and spellMap:contains('Magical')) then
			state.MagicBurstMode:reset()
			if state.DisplayMode.value then update_job_states()	end
		end
	end
	
end

-------------------------------------------------------------------------------------------------------------------
-- Job-specific hooks for non-casting events.
-------------------------------------------------------------------------------------------------------------------

-- Called when a player gains or loses a buff.
-- buff == buff gained or lost
-- gain == true if the buff was gained, false if it was lost.
function job_buff_change(buff, gain)

	if state.NeverDieMode.value or state.AutoCureMode.value then 

		if buffactive['poison'] and world.area:contains('Sortie') and (player.sub_job == 'SCH' or player.sub_job == 'WHM') and spell_recasts[14] < spell_latency then 
			windower.chat.input('/ma "Poisona" <me>')
			tickdelay = os.clock() + 1.1
			
		end
	end
	if state.AutoMedicineMode.value == true then
		if buff == "Defense Down" then
			if gain then  			
				send_command('input /item "Panacea" <me>')
			end
		elseif buff == "Magic Def. Down" then
			if gain then  			
				send_command('@input /item "panacea" <me>')
			end
		elseif buff == "Max HP Down" then
			if gain then  			
				send_command('@input /item "panacea" <me>')
			end
		elseif buff == "Evasion Down" then
			if gain then  			
				send_command('@input /item "panacea" <me>')
			end
		elseif buff == "Magic Evasion Down" then
			if gain then  			
				send_command('@input /item "panacea" <me>')
			end
		elseif buff == "Dia" then
			if gain then  			
				send_command('@input /item "panacea" <me>')
			end  
		elseif buff == "Bio" then
			if gain then  			
				send_command('@input /item "panacea" <me>')
			end
		elseif buff == "Bind" then
			if gain then  			
				send_command('@input /item "panacea" <me>')
			end
		elseif buff == "slow" then
			if gain then  			
				send_command('@input /item "panacea" <me>')
			end
		elseif buff == "weight" then
			if gain then  			
				send_command('@input /item "panacea" <me>')
			end
		elseif buff == "Attack Down" then
			if gain then  			
				send_command('@input /item "panacea" <me>')
			end
		elseif buff == "Accuracy Down" then
			if gain then  			
				send_command('@input /item "panacea" <me>')
			end
		end
	
		if buff == "VIT Down" then
			if gain then
				send_command('@input /item "panacea" <me>')
			end
		elseif buff == "INT Down" then
			if gain then
				send_command('@input /item "panacea" <me>')
			end
		elseif buff == "MND Down" then
			if gain then
				send_command('@input /item "panacea" <me>')
			end
		elseif buff == "STR Down" then
			if gain then
				send_command('@input /item "panacea" <me>')
			end
		elseif buff == "AGI Down" then
			if gain then
				send_command('@input /item "panacea" <me>')
			end
		elseif buff == "poison" then
			if gain then  
				send_command('input /item "remedy" <me>')
			end
		end
		if not midaction() then
			job_update()
		end
	end
	update_melee_groups()
	handle_equipping_gear(player.status)

end

-- Custom spell mapping.
-- Return custom spellMap value that can override the default spell mapping.
-- Don't return anything to allow default spell mapping to be used.
function job_get_spell_map(spell, default_spell_map)
    if spell.skill == 'Blue Magic' then
        for category,spell_list in pairs(blue_magic_maps) do
            if spell_list:contains(spell.english) then
                return category
            end
        end
    end
end

-- Modify the default melee set after it was constructed.
function job_customize_melee_set(meleeSet)
	if state.LearningMode.value == true then 
		meleeSet = set_combine(meleeSet, sets.Learning)
	end
    handle_equipping_gear(player.status)

    return meleeSet
end

-- Modify the default idle set after it was constructed.
function job_customize_idle_set(idleSet)
    if player.mpp < 51 and (state.IdleMode.value == 'Normal' or state.IdleMode.value:contains('Sphere')) then
		if sets.latent_refresh then
			idleSet = set_combine(idleSet, sets.latent_refresh)
		end
		
		if (state.Weapons.value == 'None' or state.UnlockWeapons.value) and idleSet.main then
			local main_table = get_item_table(idleSet.main)

			if  main_table and main_table.skill == 12 and sets.latent_refresh_grip then
				idleSet = set_combine(idleSet, sets.latent_refresh_grip)
			end
		end
    end
	
	if state.LearningMode.value == true then 
		idleSet = set_combine(idleSet, sets.Learning)
	end
	if state.HippoMode.value == true then 
		idleSet = set_combine(idleSet, {feet="Hippo. Socks +1"})
	end	
	if buffactive['Tactician\'s Roll'] then 
		idleSet = set_combine(idleSet, sets.rollerRing)
	end


	handle_equipping_gear(player.status)

	return idleSet
end



-- Called by the 'update' self-command, for common needs.
-- Set eventArgs.handled to true if we don't want automatic equipping of gear.
function job_update(cmdParams, eventArgs)

end

function user_status_change(newStatus, oldStatus, eventArgs)
	local abil_recasts = windower.ffxi.get_ability_recasts()
	local spell_recasts = windower.ffxi.get_spell_recasts()
	--local player = windower.ffxi.get_player()

    if (buffactive['poison'] or buffactive['slow'] or buffactive['Rasp'] 
	    or buffactive['Dia'] or buffactive['Defense Down'] or buffactive['Magic Def. Down'] or buffactive['Max HP Down']
	    or buffactive['Evasion Down'] == "Evasion Down" or buffactive['Magic Evasion Down'] or buffactive['Bio'] or buffactive['Bind']
	    or buffactive['weight'] or buffactive['Attack Down'] or buffactive['Accuracy Down'] or buffactive['VIT Down']
	    or buffactive['INT Down'] or buffactive['MND Down'] or buffactive['STR Down'] or buffactive['AGI Down']) and spell_recasts[681] < spell_latency then		
	        windower.send_command('input /ma "Winds of Promy." <me>')
	        tickdelay = os.clock() + 1.1

		
		return
	end
	if state.NeverDieMode.value then 

		if player.sub_job == 'NIN' and not state.Buff['SJ Restriction'] and (player.in_combat or being_attacked) and player.hpp < 25 then
			state.AutoShadowMode:set('true')
			tickdelay = os.clock() + 1.1
		end
	end
end
-- Handle notifications of general user state change.
function job_state_change(stateField, newValue, oldValue)
	handle_equipping_gear(player.status)
end
function update_combat_form()
    if DW == true then
        state.CombatForm:set('DW')
    elseif DW == false then
        state.CombatForm:reset()
    end
end
function determine_haste_group()
    classes.CustomMeleeGroups:clear()
    if DW == true then
        if DW_needed <= 11 then
            classes.CustomMeleeGroups:append('MaxHaste')
        elseif DW_needed > 11 and DW_needed <= 21 then
            classes.CustomMeleeGroups:append('MidHaste')
        elseif DW_needed > 21 and DW_needed <= 27 then
            classes.CustomMeleeGroups:append('MidHaste')
        elseif DW_needed > 27 and DW_needed <= 37 then
            classes.CustomMeleeGroups:append('LowHaste')
        elseif DW_needed > 37 then
            classes.CustomMeleeGroups:append('LowHaste')
        end
    end
end
function gearinfo(commandArgs, eventArgs)
    if commandArgs[1] == 'gearinfo' then
        if type(tonumber(commandArgs[2])) == 'number' then
            if tonumber(commandArgs[2]) ~= DW_needed then
            DW_needed = tonumber(commandArgs[2])
            DW = true
            end
        elseif type(commandArgs[2]) == 'string' then
            if commandArgs[2] == 'false' then
                DW_needed = 0
                DW = false
            end
        end
        if type(tonumber(commandArgs[3])) == 'number' then
            if tonumber(commandArgs[3]) ~= Haste then
                Haste = tonumber(commandArgs[3])
            end
        end
        if not midaction() then
            job_update()
        end
    end
end
function job_handle_equipping_gear(playerStatus, eventArgs)
    determine_haste_group()
	update_combat_form()
end

function job_self_command(commandArgs, eventArgs)
	gearinfo(commandArgs, eventArgs)

    if commandArgs[1]:lower() == 'curecheat' then
		if sets.HPDown then
			equip(sets.HPDown)
			send_command('@wait 1;input /ma "Magic Fruit" <me>')
		else
			add_to_chat(123,"You don't have a sets.HPDown to cheat with.")
		end
		eventArgs.handled = true
	end
	if commandArgs[1]:lower() == 'elemental' then
		handle_elemental(commandArgs)
		eventArgs.handled = true			
	end
	if commandArgs[1]:lower() == 'spellset' then
        send_command('@input //aset set "'..state.Spellset.value..'"')
	end
end




function unbridled_ready()
	if state.Buff['Unbridled Learning'] or state.Buff['Unbridled Wisdom'] or windower.ffxi.get_ability_recasts()[81] < latency then
		return true
	else
		return false
	end
end

function job_tick()
	if user_status_change() then return true end
	if check_arts() then return true end
	if check_buff() then return true end
	if check_buffup() then return true end
	if state.AutoBLUSpam.value and player.in_combat and player.target.type == "MONSTER" and not moving then
		if check_tp_lower() then return true end
			tickdelay = os.clock() + 1.5
		return true
	end
	return false
end

function check_arts()
	if (player.sub_job == 'SCH' and not (state.Buff['SJ Restriction'] or arts_active())) and (buffup ~= '' or (not data.areas.cities:contains(world.area) and (state.AutoArts.value or state.AutoBuffMode.value ~= 'Off'))) and not moving or buffactive['Sneak'] or buffactive['Invisible']  then
	
		local abil_recasts = windower.ffxi.get_ability_recasts()

		if abil_recasts[228] < latency then
			send_command('@input /ja "Light Arts" <me>')
			windower.chat.input:schedule(2.5,'/ja "Addendum: White" <me>')
			tickdelay = os.clock() + 1
			return true
		elseif not (buffactive['Addendum: White'] and abil_recasts[228] < latency) then
			windower.chat.input:schedule(1.5,'/ja "Addendum: White" <me>')
			tickdelay = os.clock() + 1
			return true
		end
	end
	
	return false
end

-------------------------------------------------------------------------------------------------------------------
-- Utility functions specific to this job.
-------------------------------------------------------------------------------------------------------------------

-- Handling Elemental spells within Gearswap.
-- Format: gs c elemental <nuke, helix, skillchain1, skillchain2, weather>
function handle_elemental(cmdParams)
    -- cmdParams[1] == 'elemental'
    -- cmdParams[2] == ability to use

    if not cmdParams[2] then
        add_to_chat(123,'Error: No elemental command given.')
        return
    end
    local command = cmdParams[2]:lower()
	
	if command == 'spikes' then
		windower.chat.input('/ma "'..data.elements.spikes_of[state.ElementalMode.value]..' Spikes" <me>')
		return
	elseif command == 'enspell' then
		windower.chat.input('/ma "En'..data.elements.enspell_of[state.ElementalMode.value]..'" <me>')
		return
	--Leave out target, let shortcuts auto-determine it.
	elseif command == 'weather' then
		if player.sub_job == 'RDM' then
			windower.chat.input('/ma "Phalanx" <me>')
		else
			local spell_recasts = windower.ffxi.get_spell_recasts()
			if (player.target.type == 'SELF' or not player.target.in_party) and buffactive[data.elements.storm_of[state.ElementalMode.value]] and not buffactive['Klimaform'] and spell_recasts[287] < spell_latency then
				windower.chat.input('/ma "Klimaform" <me>')
			else
				windower.chat.input('/ma "'..data.elements.storm_of[state.ElementalMode.value]..'"')
			end
		end
		return
	end

	local target = '<t>'
	if cmdParams[3] then
		if tonumber(cmdParams[3]) then
			target = tonumber(cmdParams[3])
		else
			target = table.concat(cmdParams, ' ', 3)
			target = get_closest_mob_id_by_name(target) or '<t>'
		end
	end

    if command == 'nuke' then
		local spell_recasts = windower.ffxi.get_spell_recasts()
		
		if state.ElementalMode.value == 'Light' then
			if spell_recasts[29] < spell_latency and actual_cost(get_spell_table_by_name('Banish II')) < player.mp then
				windower.chat.input('/ma "Banish II" '..target..'')
			elseif spell_recasts[28] < spell_latency and actual_cost(get_spell_table_by_name('Banish')) < player.mp then
				windower.chat.input('/ma "Banish" '..target..'')
			else
				add_to_chat(123,'Abort: Banishes on cooldown or not enough MP.')
			end

		else
			if player.job_points[(res.jobs[player.main_job_id].ens):lower()].jp_spent > 99 and spell_recasts[get_spell_table_by_name(data.elements.nuke_of[state.ElementalMode.value]..' III').id] < spell_latency and actual_cost(get_spell_table_by_name(data.elements.nuke_of[state.ElementalMode.value]..' III')) < player.mp then
				windower.chat.input('/ma "'..data.elements.nuke_of[state.ElementalMode.value]..' III" '..target..'')
			else
				local tiers = {' III',' II',''}
				for k in ipairs(tiers) do
					if spell_recasts[get_spell_table_by_name(data.elements.nuke_of[state.ElementalMode.value]..''..tiers[k]..'').id] < spell_latency and actual_cost(get_spell_table_by_name(data.elements.nuke_of[state.ElementalMode.value]..''..tiers[k]..'')) < player.mp then
						windower.chat.input('/ma "'..data.elements.nuke_of[state.ElementalMode.value]..''..tiers[k]..'" '..target..'')
						return
					end
				end
				add_to_chat(123,'Abort: All '..data.elements.nuke_of[state.ElementalMode.value]..' nukes on cooldown or or not enough MP.')
			end
		end
			
	elseif command == 'ninjutsu' then
		windower.chat.input('/ma "'..data.elements.ninjutsu_nuke_of[state.ElementalMode.value]..': Ni" '..target..'')
			
	elseif command == 'smallnuke' then
		local spell_recasts = windower.ffxi.get_spell_recasts()
	
		local tiers = {''}
		for k in ipairs(tiers) do
			if spell_recasts[get_spell_table_by_name(data.elements.nuke_of[state.ElementalMode.value]..''..tiers[k]..'').id] < spell_latency and actual_cost(get_spell_table_by_name(data.elements.nuke_of[state.ElementalMode.value]..''..tiers[k]..'')) < player.mp then
				windower.chat.input('/ma "'..data.elements.nuke_of[state.ElementalMode.value]..''..tiers[k]..'" '..target..'')
				return
			end
		end
		add_to_chat(123,'Abort: All '..data.elements.nuke_of[state.ElementalMode.value]..' nukes on cooldown or or not enough MP.')
		
	elseif command:contains('tier') then
		local spell_recasts = windower.ffxi.get_spell_recasts()
		local tierlist = {['tier1']='',['tier2']=' II',['tier3']=' III'}
		
		windower.chat.input('/ma "'..data.elements.nuke_of[state.ElementalMode.value]..tierlist[command]..'" '..target..'')

	elseif command:contains('aga') or command == 'aja' then
		local spell_recasts = windower.ffxi.get_spell_recasts()
		local tierkey = {'aga2','aga1'}
		local tierlist = {['aga2']='ga II',['aga1']='ga',}
		if command == 'aga' then
			for i in ipairs(tierkey) do
				if spell_recasts[get_spell_table_by_name(data.elements.nukega_of[state.ElementalMode.value]..''..tierlist[tierkey[i]]..'').id] < spell_latency and actual_cost(get_spell_table_by_name(data.elements.nukega_of[state.ElementalMode.value]..''..tierlist[tierkey[i]]..'')) < player.mp then
					windower.chat.input('/ma "'..data.elements.nukega_of[state.ElementalMode.value]..''..tierlist[tierkey[i]]..'" '..target..'')
					return
				end
			end
		else
			windower.chat.input('/ma "'..data.elements.nukega_of[state.ElementalMode.value]..tierlist[command]..'" '..target..'')
		end

	elseif command == 'ara' then
		windower.chat.input('/ma "'..data.elements.nukera_of[state.ElementalMode.value]..'ra" '..target..'')
		
	elseif command == 'helix' then
		windower.chat.input('/ma "'..data.elements.helix_of[state.ElementalMode.value]..'helix" '..target..'')
	
	elseif command == 'ancientmagic' then
		windower.chat.input('/ma "'..data.elements.ancient_nuke_of[state.ElementalMode.value]..'" '..target..'')
		
	elseif command == 'ancientmagic2' then
		windower.chat.input('/ma "'..data.elements.ancient_nuke_of[state.ElementalMode.value]..' II" '..target..'')
		
	elseif command == 'enfeeble' then
		windower.chat.input('/ma "'..data.elements.elemental_enfeeble_of[state.ElementalMode.value]..'" '..target..'')
	
	elseif command == 'bardsong' then
		windower.chat.input('/ma "'..data.elements.threnody_of[state.ElementalMode.value]..' Threnody" '..target..'')
	
	elseif command == 'blu' then
		windower.chat.input('/ma "'..data.elements.blue_of[state.ElementalMode.value]..'" '..target..'')
	
	elseif command == 'blu2' then
		windower.chat.input('/ma "'..data.elements.blue2_of[state.ElementalMode.value]..'" '..target..'')
	elseif command == 'unbridledspell' then
		windower.chat.input('/ma "'..data.elements.unbridled_spells[state.ElementalMode.value]..'" '..target..'')
	else
        add_to_chat(123,'Unrecognized elemental command.')
    end
	
end


function update_melee_groups()
	if player.equipment.main then
		classes.CustomMeleeGroups:clear()
		
		if player.equipment.main == "Tizona" and state.Buff['Aftermath: Lv.3'] then
				classes.CustomMeleeGroups:append('AM')
		end
	end	
end


function check_tp_lower()
	local spell_recasts = windower.ffxi.get_spell_recasts()

	if spell_recasts[573] < spell_latency and silent_can_use(573) then
		windower.chat.input('/ma "Feather Tickle" <t>')
		tickdelay = os.clock() + 2
		return true
	elseif spell_recasts[684] < spell_latency and silent_can_use(684) then
		windower.chat.input('/ma "Reaving Wind" <t>')
		tickdelay = os.clock() + 2
		return true
	else
		return false
	end
end

function check_buff()
	if state.AutoBuffMode.value ~= 'Off' and not data.areas.cities:contains(world.area) then
		local spell_recasts = windower.ffxi.get_spell_recasts()
		for i in pairs(buff_spell_lists[state.AutoBuffMode.Value]) do
			if not buffactive[buff_spell_lists[state.AutoBuffMode.Value][i].Buff] and (buff_spell_lists[state.AutoBuffMode.Value][i].When == 'Always' or (buff_spell_lists[state.AutoBuffMode.Value][i].When == 'Combat' and (player.in_combat or being_attacked)) or (buff_spell_lists[state.AutoBuffMode.Value][i].When == 'Engaged' and player.status == 'Engaged') or (buff_spell_lists[state.AutoBuffMode.Value][i].When == 'Idle' and player.status == 'Idle') or (buff_spell_lists[state.AutoBuffMode.Value][i].When == 'OutOfCombat' and not (player.in_combat or being_attacked))) and spell_recasts[buff_spell_lists[state.AutoBuffMode.Value][i].SpellID] < spell_latency and silent_can_use(buff_spell_lists[state.AutoBuffMode.Value][i].SpellID) then
				if not unbridled_spells:contains(buff_spell_lists[state.AutoBuffMode.Value][i].Name) or unbridled_ready() then
					windower.chat.input('/ma "'..buff_spell_lists[state.AutoBuffMode.Value][i].Name..'" <me>')
					tickdelay = os.clock() + 2
					return true
				end
			end
		end
		if player.sub_job == 'SCH' then

			if not buffactive[data.elements.storm_of[state.ElementalMode.value]] and actual_cost(get_spell_table_by_name(data.elements.storm_of[state.ElementalMode.value])) < player.mp then
				windower.chat.input('/ma "'..data.elements.storm_of[state.ElementalMode.value]..'"')
				tickdelay = os.clock() + 1.1
				return true
			else
				return false
			end
		end
		if player.in_combat and player.sub_job == 'WAR' then
			local abil_recasts = windower.ffxi.get_ability_recasts()

			if not buffactive.Berserk and abil_recasts[1] < latency then
				windower.chat.input('/ja "Berserk" <me>')
				tickdelay = os.clock() + 1.1
				return true
			elseif buffactive.Defender then
				send_command('@wait .5;cancel Defender')
				tickdelay = os.clock() + 1.1
				return true
			elseif not buffactive.Aggressor and abil_recasts[4] < latency then
				windower.chat.input('/ja "Aggressor" <me>')
				tickdelay = os.clock() + 1.1
				return true
			elseif player.sub_job == 'WAR' and not buffactive.Warcry and abil_recasts[2] < latency then
				windower.chat.input('/ja "Warcry" <me>')
				tickdelay = os.clock() + 1.1
				return true
			end
		end
		if player.in_combat and player.sub_job == 'WAR' and state.AutoBuffMode.value == 'Defend' then

			local abil_recasts = windower.ffxi.get_ability_recasts()
	
			if buffactive.Berserk then
				send_command('@wait .5;cancel Berserk')
				tickdelay = os.clock() + 1.1
				return true
			elseif not buffactive.Defender and abil_recasts[3] < latency then
				windower.chat.input('/ja "Defender" <me>')
				tickdelay = os.clock() + 1.1
				return true
			elseif not buffactive.Warcry and abil_recasts[2] < latency then
				windower.chat.input('/ja "Warcry" <me>')
				tickdelay = os.clock() + 1.1
				return true
			else
				return false
			end
		end
		

	else
		return false
	end
end

function check_buffup()
	if buffup ~= '' then
		local needsbuff = false
		for i in pairs(buff_spell_lists[buffup]) do
			if not buffactive[buff_spell_lists[buffup][i].Buff] and silent_can_use(buff_spell_lists[buffup][i].SpellID) then
				needsbuff = true
				break
			end
		end
	
		if not needsbuff then
			add_to_chat(217, 'All '..buffup..' buffs are up!')
			buffup = ''
			return false
		end
		
		local spell_recasts = windower.ffxi.get_spell_recasts()
		
		for i in pairs(buff_spell_lists[buffup]) do
			if not buffactive[buff_spell_lists[buffup][i].Buff] and silent_can_use(buff_spell_lists[buffup][i].SpellID) and spell_recasts[buff_spell_lists[buffup][i].SpellID] < spell_latency then
				windower.chat.input('/ma "'..buff_spell_lists[buffup][i].Name..'" <me>')
				tickdelay = os.clock() + 2
				return true
			end
		end
		
		return false
	else
		return false
	end
end

----- buff -----
--[[
usage : for AutoBuffMode 
add
	state.AutoBuffMode:options('Off','Auto','Cleave') or any

bind add any like

	send_command('bind ^f2 gs c toggle AutoBuffMode')

	----
for buffup 

gc c buffup name 

like 
gc c buffup mp 

bind add any like

	send_command('bind !f2 gs c buffup')


]]

buff_spell_lists = {
	Auto = {--Options for When are: Always, Engaged, Idle, OutOfCombat, Combat
		{Name='Erratic Flutter',	Buff='Haste',			SpellID=710,	When='Always'},
		{Name='Battery Charge',		Buff='Refresh',			SpellID=662,	When='Idle'},
		{Name='Refresh',			Buff='Refresh',			SpellID=109,	When='Idle'},
		{Name='Nat. Meditation',	Buff='Attack Boost',	SpellID=700,	When='Engaged'},
		{Name='Mighty Guard',		Buff='Mighty Guard',	SpellID=750,	When='Combat'},
		{Name='Aquaveil',	Buff='Aquaveil',	SpellID=55,		When='Always'},
	},
	
	Default = {
		{Name='Aquaveil',	Buff='Aquaveil',	SpellID=55,		Reapply=false},
		{Name='Erratic Flutter',	Buff='Haste',			SpellID=710,	Reapply=false},
		{Name='Battery Charge',		Buff='Refresh',			SpellID=662,	Reapply=false},
		{Name='Refresh',			Buff='Refresh',			SpellID=109,	Reapply=false},
		{Name='Phalanx',			Buff='Phalanx',			SpellID=106,	Reapply=false},
		{Name='Barrier Tusk',		Buff='Phalanx',			SpellID=685,	Reapply=false},
		{Name='Stoneskin',			Buff='Stoneskin',		SpellID=54,		Reapply=false},
		{Name='Occultation',		Buff='Blink',			SpellID=679,	Reapply=false},
		{Name='Blink',				Buff='Blink',			SpellID=53,		Reapply=false},
		{Name='Mighty Guard',		Buff='Mighty Guard',	SpellID=750,	Reapply=false},
		{Name='Nat. Meditation',	Buff='Attack Boost',	SpellID=700,	Reapply=false},
	},
	Defend = {--Options for When are: Always, Engaged, Idle, OutOfCombat, Combat
	{Name='Phalanx',			Buff='Phalanx',			SpellID=106,	When='Always'},
	{Name='Occultation',		Buff='Blink',			SpellID=679,	When='Always'},
	{Name='Stoneskin',			Buff='Stoneskin',		SpellID=54,		When='Always'},
	{Name='Cocoon',             Buff='Cocoon',          SpellID=547,    When='Always'},
    },
	melee = {--Options for When are: Always, Engaged, Idle, OutOfCombat, Combat
	{Name='Erratic Flutter',	Buff='Haste',			SpellID=710,	When='Engaged'},
	--{Name='Occultation',		Buff='Blink',			SpellID=679,	When='Always'},
	{Name='Nat. Meditation',	Buff='Attack Boost',	SpellID=700,	When='Engaged'},
	{Name='Phalanx',			Buff='Phalanx',			SpellID=106,	When='Engaged'},
	{Name='Mighty Guard',		Buff='Mighty Guard',	SpellID=750,	When='Engaged'},
    },
	mp = {
		{Name='Aquaveil',	Buff='Aquaveil',	SpellID=55,		When='Always'},
		{Name='Erratic Flutter',	Buff='Haste',			SpellID=710,	When='Always'},
		{Name='Battery Charge',		Buff='Refresh',			SpellID=662,	When='Always'},
		{Name='Refresh',			Buff='Refresh',			SpellID=109,	When='Always'},
		{Name='Phalanx',			Buff='Phalanx',			SpellID=106,	When='Always'},
		{Name='Barrier Tusk',		Buff='Phalanx',			SpellID=685,	When='Always'},
		{Name='Stoneskin',			Buff='Stoneskin',		SpellID=54,		When='Always'},
		{Name='Occultation',		Buff='Blink',			SpellID=679,	When='Always'},
		{Name='Blink',				Buff='Blink',			SpellID=53,		When='Always'},
		{Name='Carcharian Verve',	Buff='Aquaveil',		SpellID=745,	When='Always'},
		{Name='Memento Mori',		Buff='Magic Atk. Boost',SpellID=538,	When='Always'},
	},
	Cleave = {
		{Name='Aquaveil',	Buff='Aquaveil',	SpellID=55,		When='Always'},
		{Name='Erratic Flutter',	Buff='Haste',			SpellID=710,	When='Always'},
		{Name='Battery Charge',		Buff='Refresh',			SpellID=662,	When='Always'},
		{Name='Refresh',			Buff='Refresh',			SpellID=109,	When='Always'},
		{Name='Phalanx',			Buff='Phalanx',			SpellID=106,	When='Always'},
		{Name='Barrier Tusk',		Buff='Phalanx',			SpellID=685,	When='Always'},
		{Name='Stoneskin',			Buff='Stoneskin',		SpellID=54,		When='Always'},
		{Name='Occultation',		Buff='Blink',			SpellID=679,	When='Always'},
		--{Name='Blink',				Buff='Blink',			SpellID=53,		When='Always'},
		{Name='Carcharian Verve',	Buff='Aquaveil',		SpellID=745,	When='Always'},
		{Name='Memento Mori',		Buff='Magic Atk. Boost',SpellID=538,	When='Always'},
	},
	Vagary = {
		{Name='Erratic Flutter',	Buff='Haste',			SpellID=710,	When='Always'},
		{Name='Battery Charge',		Buff='Refresh',			SpellID=662,	When='Always'},
		{Name='Refresh',			Buff='Refresh',			SpellID=109,	When='Always'},
		{Name='Phalanx',			Buff='Phalanx',			SpellID=106,	When='Always'},
		{Name='Aquaveil',	Buff='Aquaveil',	SpellID=55,		When='Always'},
		--{Name='Barrier Tusk',		Buff='Phalanx',			SpellID=685,	When='Always'},
		--{Name='Stoneskin',			Buff='Stoneskin',		SpellID=54,		When='Always'},
		{Name='Occultation',		Buff='Blink',			SpellID=679,	When='Always'},
		--{Name='Blink',				Buff='Blink',			SpellID=53,		When='Always'},
		--{Name='Carcharian Verve',	Buff='Aquaveil',		SpellID=745,	When='Always'},
		--{Name='Memento Mori',		Buff='Magic Atk. Boost',SpellID=538,	When='Always'},
	},
	VagaryParty = {
		{Name='Carcharian Verve',	Buff='Aquaveil',		SpellID=745,	When='Always'},
		{Name='Aquaveil',	Buff='Aquaveil',	SpellID=55,		When='Always'},
		{Name='Erratic Flutter',	Buff='Haste',			SpellID=710,	When='Always'},
		{Name='Battery Charge',		Buff='Refresh',			SpellID=662,	When='Always'},
		--{Name='Refresh',			Buff='Refresh',			SpellID=109,	When='Always'},
		{Name='Phalanx',			Buff='Phalanx',			SpellID=106,	When='Always'},
		--{Name='Barrier Tusk',		Buff='Phalanx',			SpellID=685,	When='Always'},
		{Name='Diamondhide',		Buff='Stoneskin',		SpellID=632,		When='Always'},
		{Name='Occultation',		Buff='Blink',			SpellID=679,	When='Always'},
		--{Name='Blink',				Buff='Blink',			SpellID=53,		When='Always'},
		--{Name='Carcharian Verve',	Buff='Aquaveil',		SpellID=745,	When='Always'},
		--{Name='Memento Mori',		Buff='Magic Atk. Boost',SpellID=538,	When='Always'},
	},
}
